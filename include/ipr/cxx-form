// -*- C++ -*-
//
// This file is part of The Pivot framework.
// Written by Gabriel Dos Reis.
// See LICENSE for copyright and license notices.
//

#ifndef IPR_FORM_INCLUDED
#define IPR_FORM_INCLUDED

#include <ipr/synopsis>
#include <ipr/ancillary>

// -- The IPR focuses primarily on capturing the semantics of C++, not mimic - with 
// -- high fidelity - the ISO C++ source-level syntax minutiae, grammars, and other obscurities.
// -- The IPR model of declaration reflects that semantics-oriented view.  Occasionally, it 
// -- is necessary to bridge the gap between the generalized semantics model and the
// -- irregularities and other grammatical hacks via IPR directives.  Some of those
// -- directives need to refer to some form of input source level constructs, especially in 
// -- cases of templated declarations involving non-ground types.
// -- This file defines interfaces for some syntactic forms, i.e. abstractions of syntactic
// -- input, to aid complete embedding of the ISO C++ specification.
// -- Note: There is no effort in this file to reify the parse trees of the ISO C++ grammar.

namespace ipr::cxx_form {
    // -- Abstraction of ISO C++ Declarators:
    // -- The C and C++ languages have tortuous grammars for declarations, whereby
    // -- declarations are structured to mimic use (operator precedence).  A declaration
    // -- is made of two essential pieces (decl-specifiers-seq and declarator), with an
    // -- an optional component representing the initializer.  The decl-specifier-seq
    // -- is a soup made of decl-specifier such as `static`, `extern`, etc. and simple-type
    // -- names such as `int`, and type qualifiers.  Compound types are made with
    // -- type-constructors such as `*` (pointer) or `&` (reference), `[N]` (array), etc.  
    // -- The type-constructors (which really imply some form of data indirection) are specified
    // -- along with the name being introduced, making up the declarator.
    // -- Pointer-style type-constructors are modeled by `Indirector`.
    // -- Mapping-style type constructors (functions, arrays) are modeled by classes in
    // -- `Morphism` hierarchy.
    // -- Complete declarators that have mapping-style type contructors are modelled in the
    // -- `Species_declarator` class hierarchy.

    struct Indirector_visitor;      // Base class of visitors for traversing `Indirector`s.

    // Base class for objects representing ptr-operator (C++ grammar).
    // While the source-level grammar of ISO C++ does not allow attributes on
    // reference-style ptr-operator, the representation adopted here makes room for that possibility.
    // Hence all `Indirector` objects have an `attributes()` operation.
    // At the input source level, `Indirector`s precede the name being declared in the declarator.
    struct Indirector {
        struct Pointer;             // pointer indirector
        struct Reference;           // reference indirector
        struct Member;              // non-static member indirector
        virtual const Sequence<Attribute>& attributes() const = 0;
        virtual void accept(Indirector_visitor&) const = 0;
    };

    // A `Pointer` indirector object is a simple possibly cv-qualified pointer indirection.
    // And object of this type corresponds to the instance of the ptr-operator C++ grammar:
    //      `*` attribute-specifier-seq_opt cv-qualifier-seq_opt
    struct Indirector::Pointer : Indirector {
        virtual Type_qualifiers qualifiers() const = 0;
    };

    // Syntactic indication of reference binding flavor.
    enum class Reference_flavor {
        Lvalue,                     // "&" ptr-operator in an indirector
        Rvalue                      // "&&" ptr-operator in an indirector
    };

    // A `Reference` indirector object is a reference indirection.
    // An object of this type corresponds to an instance of any of the following alternatives
    // of the ptr-operator C++ grammar production:
    //     `&` attribute-specifier-seq_opt
    //     `&&` attribute-specifier-seq_opt
    struct Indirector::Reference : Indirector {
        virtual Reference_flavor flavor() const = 0;
    };

    // A member `Indirector` object represents a ptr-operator that specifies a pointer to member.
    // An object of this type corresponds to an instance of the following alternative of the
    // ptr-operator C++ grammar production:
    //     nested-named-specifier `*` attribute-specifier-seq_opt cv-qualifier-seq_opt
    struct Indirector::Member : Indirector {
        virtual const Expr& scope() const = 0;
        virtual Type_qualifiers qualifiers() const = 0;
    };

    // Traversal of Indirector objects is facilitated by visitor classes deriving
    // from this interface.
    struct Indirector_visitor {
        virtual void visit(const Indirector::Pointer&) = 0;
        virtual void visit(const Indirector::Reference&) = 0;
        virtual void visit(const Indirector::Member&) = 0;
    };

    // -- Species and Morphisms
    // A species declarator introduces a name along with typical usage of a named being declared.
    // This usage pattern is captured by a suffix of `Morphism`s.  A `Morphism` is a form that
    // specifies the type constuctor from the declared entity to the type of typical uses of that 
    // entity in expressions.
    //   - Function: a callable expression, the entity is typically called
    //   - Array: a table expression, the entity is typically indexed

    // -- Morphism and navigation
    struct Morphism_visitor;

    struct Morphism {
        struct Function;                            // -- (T, int) & noexcept
        struct Array;                               // -- [34][] [[S::A]]
        virtual const Sequence<Attribute>& attributes() const = 0;
        virtual void accept(Morphism_visitor&) const = 0;
    };

    struct Morphism_visitor {
        virtual void visit(const Morphism::Function&) = 0;
        virtual void visit(const Morphism::Array&) = 0;
    };

    // -- Species and navigation
    struct Species_visitor;

    // A species declarator is either a name (possibly a pack), or a parenthesized term declarator, followed
    // by a possibly empty sequence of morphisms.  For instance, in the declaration
    //        bool (*pfs[8])(int)
    // that declares pfs as an array of 8 pointers to functions taking an `int` returning a `bool`, the complete
    // declarator `(*pfs[8])(int)` is a parenthesized species (`(*pfs[8])`) with the suffix consisting exactly of
    // the singleton sequence of function morphism `(int)`.
    // The term declarator `*pfs[8]` in turn has the indirectors is comprised of the single pointer indirector `*`,
    // and of the id species `pfs` with array suffix `[8]`.
    struct Species_declarator {
        struct Unqualified_id;                      // -- int p;
        struct Pack;                                // -- Ts... xs
        struct Qualified_id;                        // -- int X<T>::count;
        struct Parenthesized;                       // parenthesized term declarator -- (*p)
        virtual const Sequence<Morphism>& suffix() const = 0;
        virtual void accept(Species_visitor&) const = 0;
    };

    // Base class for representing instances of the C++ production id-expression in the C++
    // grammar for declarator-id.
    struct Declarator_id : Species_declarator {
        virtual const Sequence<Attribute>& attributes() const = 0;
    };

    // Representation of an unqualified-id in an instance of the C++ grammar production for declarator-id.
    // The operation `name()` returns an optional value for use in representing instances of the C++
    // grammar production for noptr-abstract-declarator.
    struct Species_declarator::Unqualified_id : Declarator_id {
        virtual Optional<ipr::Name> name() const = 0;
    };

    // Representation of a pack parameter in an instance of the C++ grammar production for declarator-id
    // The operation `name()` returns an optional value for use in representing instances of the C++
    // grammar production for noptr-abstract-abstract-declarator.
    // Example:
    //     ... x
    struct Species_declarator::Pack : Declarator_id {
        virtual Optional<ipr::Identifier> name() const = 0;
    };

    // Representation of a qualified-id in an instance of the C++ grammar production for declarator-id
    // Such qualified-id are used in the out-of-class definition of an entity.
    struct Species_declarator::Qualified_id : Declarator_id {
        virtual const ipr::Expr& scope() const = 0;
        virtual const ipr::Name& member() const = 0;
    };

    // -- Declarator.
    // -- A declarator is either a term, or a species with a target type.
    // -- A term is a sequence of indirectors followed by a species.
    // -- A species indicates the typical usage syntactic structure of the named being declared.

    struct Declarator_visitor;

    struct Declarator {
        struct Term;                                // *p or (&a)[42]
        struct Targeted;                            // f(T& p) -> int
        virtual const Species_declarator& species() const = 0;
        virtual void accept(Declarator_visitor&) const = 0;
    };

    // A term declarator is a sequence of `Indirector`s followed by a species declarator.
    // An object of this type represents an instance of the first alternative of the C++ 
    // grammar production for declarator:
    //     ptr-declarator
    // Examples:
    //     (&a)[42]
    //     *f(T) noexcept
    struct Declarator::Term : Declarator {
        virtual const Sequence<Indirector>& indirectors() const = 0;
    };

    // A targeted declarator is a species declarator with a trailing return type,
    // given by the `target()` operation.
    // An object of this type represents an instance of the second alternative of the C++
    // grammar production for declarator:
    //     noptr-declarator paramters-and-qualifiers trailing-return-type
    // In particular, the `species()` of a targeted declarator has a function Morphism as 
    // last element in its `suffix()`.  Furthermore, a targeted declarator lacks indirectors.
    // Examples:
    //    f(T a, U b) -> decltype(a + b)
    struct Declarator::Targeted : Declarator {
        virtual const Type& target() const = 0;
    };

    // Traversal of declarator objects is facilitated by visitor classes deriving
    // from this interface.
    struct Declarator_visitor {
        virtual void visit(const Declarator::Term&) = 0;
        virtual void visit(const Declarator::Targeted&) = 0;
    };

    // A term declarator requiring parentheses to obey operator precedence rules, or just
    // a redundant parentheses. An object of this type represents an instance of the fourth
    // alternative of the C++ grammar for noptr-declarator:
    //      `(` ptr-declarator `)`
    // Example:
    //      (a)
    //      (*p)
    struct Species_declarator::Parenthesized : Species_declarator {
        virtual const Declarator::Term& term() const = 0;
    };

    // -- Function Morphism
    // A morphism for a declarator indicating something that can be called.
    // An object of this type captures the components introduced by an instance the second 
    // alternative of the C++ grammar of noptr-delarator:
    //    noptr-declarator parameters-and-qualifiers
    struct Morphism::Function : Morphism {
        virtual const Parameter_list& parameters() const = 0;
        virtual Type_qualifiers qualifiers() const = 0;
        virtual Binding_mode binding_mode() const = 0;
        virtual Optional<Expr> throws() const = 0;
    };

    // -- Array Morphism
    // A morphism for a declarator indicating something that can be indexed.
    // An object of this type captures the components introduced by an instance the third
    // alternative of the C++ grammar of noptr-delarator:
    //    noptr-declarator `[` constant-expression_opt `]` attribute-specifier-seq_opt
    struct Morphism::Array : Morphism {
        virtual Optional<Expr> bound() const = 0;
    };

    // Traversal of species objects is facilitated by visitor classes deriving
    // from this interface.
    struct Species_visitor {
        virtual void visit(const Species_declarator::Unqualified_id&) = 0;
        virtual void visit(const Species_declarator::Pack&) = 0;
        virtual void visit(const Species_declarator::Qualified_id&) = 0;
        virtual void visit(const Species_declarator::Parenthesized&) = 0;
    };

    struct Proclamator_visitor;

    struct Proclamator {
        struct Initialized;
        struct Constrained;
        virtual const Declarator& declarator() const = 0;
        virtual Decl& result() const = 0;
        virtual void accept(Proclamator_visitor&) const = 0;
    };

    struct Proclamator::Initialized : Proclamator {
        virtual Optional<Expr> initializer() const = 0;
    };

    struct Proclamator::Constrained : Proclamator {
        virtual const Expr& constraint() const = 0;
    };

    struct Proclamator_visitor {
        virtual void visit(const Proclamator::Initialized&) = 0;
        virtual void visit(const Proclamator::Constrained&) = 0;
    };
}

#endif // IPR_FORM_INCLUDED
