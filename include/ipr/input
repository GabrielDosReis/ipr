// -*- C++ -*-
//
// This file is part of The Pivot framework.
// Written by Gabriel Dos Reis.
// See LICENSE for copyright and license notices.
//

#include <cstddef>
#include <span>
#include <filesystem>

namespace ipr::input {
    // Type for the error code values used by the host OS.
#ifdef _WIN32
    using ErrorCode = DWORD;
#else
    using ErrorCode = int;
#endif

    // String type preferred by the host OS to specify pathnames.
    using SystemPath = std::filesystem::path::string_type;

    // Exception type used to signal inability of the host OS to access a file.
    struct AccessError {
        SystemPath path;
        ErrorCode error_code;
    };

    // Exception type used to signal the file designated by th `path` is not a regular file.
    struct RegularFileError {
        SystemPath path;
    };

    // Exception type used to signal inability of the host OS to memory-map a file.
    struct FileMappingError {
        SystemPath path;
        ErrorCode error_code;
    };

    // A morsel is a pierce of source text designated by an offset from
    // from the start of the source and its extent in bytes. 
    struct Morsel {
        std::uint64_t offset : 48;      // offset from the beginning of containing text
        std::uint64_t length : 16;      // number of bytes from the start
    };

    // Descriptor for a physical line from an input source file.
    struct PhysicalLine {
        Morsel morsel { };
        std::uint32_t number { };

        bool empty() const { return morsel.length == 0; }
    };

    // A logical line is either a simple phyiscal line or a composite of multiple
    // physical lines spliced together.
    enum class LineSort : std::uint8_t {
        Simple = 0x01,          // A simple, non-continuating physical line.
        Composite = 0x02,       // Result of spliced multiple physical lines.
    };

    struct SimpleLine {
        PhysicalLine line;
    };

    struct CompositeLine {
        std::vector<PhysicalLine> lines;
    };

    struct LineIndex {
        LineIndex(LineSort, std::uint32_t);
        LineSort sort() const { return static_cast<LineSort>(srt); }
        std::uint32_t index() const { return idx; }
    private:
        std::uint32_t srt : 2;
        std::uint32_t idx : 30;
    };

    static_assert(sizeof(LineIndex) == 4);

    // Input source file mapped to memory as sequence of raw bytes.
    // UTF-8 is assumed as the encoding of the text.
    struct SourceFile {
        using View = std::span<const char8_t>;
        struct LineRange;
        
        explicit SourceFile(const SystemPath&);
        SourceFile(SourceFile&&) noexcept;
        ~SourceFile();
        LineRange lines() const noexcept;
        View contents() const noexcept { return view; }
        View contents(Morsel m) const noexcept;
    private:
        View view;
    };

    // A source file line range is an input_range of morsels, each representing a physical 
    // line in the input source file.
    struct SourceFile::LineRange {
        using difference_type = std::ptrdiff_t;
        struct iterator;
        explicit LineRange(const SourceFile&);
        iterator begin() noexcept;
        iterator end() noexcept;
    private:
        const SourceFile* src;
        const char8_t* ptr;
        PhysicalLine cache { };
        void next_line() noexcept;
    };

    // An iterator for input source file line range.
    struct SourceFile::LineRange::iterator {
        using difference_type = std::ptrdiff_t;
        using value_type = Morsel;
        using iterator_category = std::input_iterator_tag;

        explicit iterator(LineRange* r) noexcept : range{r} { }
        PhysicalLine operator*() const noexcept;
        iterator& operator++() noexcept;
        void operator++(int) noexcept { ++(*this); }
        bool operator==(const iterator& that) const noexcept { return range == that.range; }
        bool operator!=(const iterator& that) const noexcept = default;
    private:
        LineRange* range;
    };

    inline SourceFile::LineRange SourceFile::lines() const noexcept
    {
        return LineRange{*this};
    }

    inline SourceFile::LineRange::iterator SourceFile::LineRange::begin() noexcept
    {
        return iterator{this};
    }

    inline SourceFile::LineRange::iterator SourceFile::LineRange::end() noexcept
    {
        return iterator{nullptr};
    }

    // A depot of lines read from an input source file.
    struct LineDepot {
        std::vector<SimpleLine> simples;
        std::vector<CompositeLine> composites;
        std::vector<LineIndex> indices;
    };

    // An input source listing is a source file with its lines read into logical lines.
    struct SourceListing : SourceFile {
        explicit SourceListing(const SystemPath&);
        const SimpleLine& simple_line(LineIndex) const;
        const CompositeLine& composite_line(LineIndex) const;
        const std::vector<LineIndex>& logical_lines() const { return depot.indices; }
    private:
        LineDepot depot;
    };
}