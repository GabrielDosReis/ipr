// -*- C++ -*-
//
// This file is part of The Pivot framework.
// Written by Gabriel Dos Reis.
// See LICENSE for copyright and license notices.
//

#ifndef IPR_INTERFACE_INCLUDED
#define IPR_INTERFACE_INCLUDED

#include <stdint.h>
#include <utility>
#include <iterator>
#include <stdexcept>
#include <type_traits>
#include <ipr/utility>

namespace ipr {
   // IPR is designed to be regular, fully general enough to
   //    (1) represent programs written in full Standard C++
   //        -- except macros -- Standard C, and possibly Fortran
   //        and other C-like languages;
   //    (2) be at the basis of semantics-based program analyses
   //        and transformations;
   //    (3) be ahead of time, i.e. accommodate future possible
   //        extensions to C++, e.g. "concepts";
   //    (4) be compiler-neutral, i.e. not the reflection of internal 
   //        data structures of any particular compiler, no matter how popular.
   //
   // The "meta-language" implemented by IPR is expression-based.  It
   // does not try to mimic the barnacles that the ISO C++ specification
   // has grown over decades -- that way lies unwarranted complexity. Rather,
   // the IPR aims for a regular, general semantics language within which the 
   // various restrictions and irregularities of ISO C++ are accounted for.
   // The focus is on semantics because that is where the essence of C++ lies.
   //
   // IPR nodes "climbing" is based on the Visitor Design Pattern.
   //
   // IPR class nodes come in two flavors:
   //     (a) the interface classes, found in this header;
   //     (b) the implementation classes, found in <ipr/impl>.
   // The primary reason for this separation is, we don't want consumers of
   // the library to critically depend on the particular implementations
   // details of the moment.  Also, it is our intent that the interfaces
   // could be implemented in various ways depending on the particular
   // constraints of the target tools.  Furthermore, a given interface class
   // can admit several implementation classes.
   //
   // A third header file <ipr/traversal> offers a set of traversal
   // facilities.  At the moment, it contains only trivial visitor classes.
   // A fourth header, <ipr/io>, contains interfaces to input/output
   // operations.  At the moment, only output in form of XPR is supported.
   // FIXME: the XPR grammar is out-of-date and is no longer known to capture IPR.
   //
   // The interface classes are non-mutating, i.e. there is no way
   // a client program could modify a node through its interface.
   // In particular, all member functions of the interface classes
   // are const member functions.
   //
   // There is an additional requirement on IPR nodes:  type nodes
   // shall have maximal sharing, i.e. be unified.  The design choices
   // behind that decision are discussed in the paper "Representing
   // C++ Directly, Compactly and Efficiently."
   //
   // Warning:  If you add any new "leaf" node type, you need to update
   //           "ipr/node-category.def" for the numerical mapping.

   struct Node;                  // universal base class for all IPR nodes

   struct Visitor;               // base class for all IPR visitor classes

   struct Annotation;            // node annotations
   struct Region;                // declarative region
   struct Comment;               // C-style and BCPL-style comments
   struct String;                // literal string

   struct Linkage;               // general language linkage
   struct Expr;                  // general expressions
   struct Name;                  // general names
   struct Type;                  // general types
   struct Directive;             // general directives
   struct Stmt;                  // general statements
   struct Decl;                  // general declarations

   struct Scope;                 // declarations in a region
   struct Overload;              // overload set
   struct Parameter_list;        // function/template parameter list

   // -------------------------------------------
   // -- results of type constructor constants --
   // -------------------------------------------
   struct Array;                 // array type
   struct As_type;               // use-expression as type
   struct Class;                 // user-defined type - declared as "class" or "struct"
   struct Decltype;              // strict type of a declaration/expression
   struct Enum;                  // user-defined type - declared as "enum" or "class enum"
   struct Tor;                   // types of constructors and destructors - not ISO C++ types
   struct Function;              // function type
   struct Namespace;             // user-defined type - declared as "namespace"
   struct Pointer;               // pointer type
   struct Ptr_to_member;         // pointer-to-member type
   struct Product;               // product type - not ISO C++ type
   struct Qualified;             // cv-qualified types
   struct Reference;             // reference type
   struct Rvalue_reference;      // rvalue-reference type
   struct Sum;                   // sum type - not ISO C++ type
   struct Forall;                // universally quantified type - Not ISO C++ type
   struct Union;                 // user-defined type - declared as "union"
   struct Auto;                  // "auto" -- each occurrence is generative
   struct Closure;               // closure type -- type of lambda expression, with capture data

   // ------------------------------------------
   // -- results of name constructor constants --
   // ------------------------------------------
   struct Identifier;            // identifier                          foo
   struct Suffix;                // Literal operator suffix       "Plato"sv
   struct Operator;              // C++ operator name             operator+
   struct Conversion;            // conversion function name   operator int
   struct Template_id;           // C++ template-id                  S<int>
   struct Type_id;               // C++ type-id                  const int*
   struct Ctor_name;             // constructor name                   T::T
   struct Dtor_name;             // destructor name                   T::~T
   struct Guide_name;            // deduction guide name 
   struct Rname;                 // de Bruijn (index, position),
                                 // find better name

   // --------------------------------------------------------
   // -- results of nullar expression constructor constants --
   // --------------------------------------------------------
   struct Phantom;               // placeholder for arrays of unknown bounds,
                                 // rethrow, empty parts of a For, etc...
   struct Eclipsis;              // the `...' in a unary fold
   struct This;                  // the special `this' reserved word for the address on the implicit object 
   struct Lambda;                // Lambda expression, packing an environment and a code pointer

   // -------------------------------------------------------
   // -- results of unary expression constructor constants --
   // -------------------------------------------------------
   struct Symbol;                // self-evaluating symbolic values: 'int' or 'nullptr'
   struct Address;               // address-of                          &a
   struct Array_delete;          // array delete-expression     delete[] p
   struct Complement;            // bitwise complement                  ~m
   struct Delete;                // delete-expression             delete p
   struct Demotion;              // inverse of an integral or floating-point
                                 // promotion -- implicit conversion
   struct Deref;                 // dereference expression              *p
   struct Expr_list;             // comma-separated expression list  x, y, z
   struct Alignof;               // alignment query                  alignof(T)
   struct Sizeof;                // sizeof expression: sizeof *p or sizeof(int)
   struct Typeid;                // typeid expression, like sizeof expression
   struct Id_expr;               // use of a name as an expression
   struct Label;                 // a label - target of a goto-statement
                                 //         or entry of a switch-statement
   struct Materialization;       // temporary materialization
   struct Not;                   // logical negation                 !cond
   struct Enclosure;             // expression in enclosed in paired delimiters, e.g. (a) or {x, y, y}
   struct Post_decrement;        // post-increment                     p++
   struct Post_increment;        // post-decrement                     p--
   struct Pre_decrement;         // pre-increment                      ++p
   struct Pre_increment;         // pre-decrement                      --p
   struct Promotion;             // integral or floating-point promotion -- implicit conversion
   struct Read;                  // lvalue to rvalue conversion  -- implicit conversion
   struct Throw;                 // throw expression               throw a
   struct Unary_minus;           // unary minus                         -a
   struct Unary_plus;            // unary plus                          +a
   struct Expansion;             // pack expansion                    t...
   struct Noexcept;              // noexcept expression        noexcept(e)
   struct Args_cardinality;      // arguments count in a parameter pack: sizeof...(args)

   // --------------------------------------------------------
   // -- results of binary expression constructor constants --
   // --------------------------------------------------------
   struct Plus;                  // addition                       a + b
   struct Plus_assign;           // in-place addition              a += b
   struct And;                   // logical and                    a && b
   struct Array_ref;             // array member selection         a[i]
   struct Arrow;                 // indirect member selection      p->m
   struct Arrow_star;            // indirect member indirection    p->*m
   struct Assign;                // assignment                     a = b
   struct Bitand;                // bitwise and                    a & b
   struct Bitand_assign;         // in-place bitwise and           a &= b
   struct Bitor;                 // bitwise or                     a | b
   struct Bitor_assign;          // in-place bitwise or            a |= b
   struct Bitxor;                // bitwise exclusive or           a ^ b
   struct Bitxor_assign;         // in-place bitwise exclusive or  a ^= b
   struct Call;                  // function call                  f(u, v)
   struct Cast;                  // C-style class                  (T) e
   struct Coercion;              // generalized type conversion -- implicit conversion
   struct Comma;                 // comma-operator                 a, b
   struct Const_cast;            // const-cast             const_cast<T&>(v)
   struct Construction;          // object construction            T(v)
   struct Div;                   // division                       a / b
   struct Div_assign;            // in-place division              a /= b
   struct Dot;                   // direct member selection        x.m
   struct Dot_star;              // direct member indirection      x.*pm
   struct Dynamic_cast;          // dynamic-cast         dynamic_cast<T&>(v)
   struct Equal;                 // equality comparison            a == b
   struct Greater;               // greater comparison             a > b
   struct Greater_equal;         // greater-or-equal comparison    a >= b
   struct Less;                  // less comparison                a < b
   struct Less_equal;            // less-equal comparison          a <= b
   struct Literal;               // literal expressions            3.14
   struct Lshift;                // left shift                     a << b
   struct Lshift_assign;         // in-place left shift            a <<= b
   struct Member_init;           // member initialization          : m(v)
   struct Minus;                 // subtraction                    a - b
   struct Minus_assign;          // in-place subtraction           a -= b
   struct Modulo;                // modulo arithmetic              a % b
   struct Modulo_assign;         // in=place modulo arithmetic     a %= b
   struct Mul;                   // multiplication                 a * b
   struct Mul_assign;            // in-place multiplication        a *= b
   struct Narrow;                // checked base to derived class conversion
   struct Not_equal;             // not-equality comparison        a != b
   struct Or;                    // logical or                     a || b
   struct Pretend;               // generalization of bitcast and reinterpret cast
   struct Qualification;         // cv-qualification conversion
   struct Reinterpret_cast;      // reinterpret-cast  reinterpret_cast<T>(v)
   struct Rshift;                // right shift                    a >> b
   struct Rshift_assign;         // in-place right shift           a >>= b
   struct Static_cast;           // static-cast            static_cast<T>(v)
   struct Widen;                 // derived to base class conversion

   struct Binary_fold;           // Primary expression of the form (a op ... op b)

   struct Mapping;               // function
   struct Rewrite;               // Semantics by translation -- unwise, but the committee can't help it
   struct Where;                 // expression with local bindings or restrictions

   // --------------------------------------------------------
   // -- result of trinary expression constructor constants --
   // --------------------------------------------------------
   struct New;                   // new-expression              new (p) T(v)
   struct Conditional;           // conditional                   p ? a : b

   // -----------------------------------------------
   // -- result of statement constructor constants --
   // -----------------------------------------------
   struct Block;                 // brace-enclosed statement sequence
   struct Break;                 // break-statement
   struct Continue;              // continue-statement
   struct Ctor_body;             // constructor-body
   struct Do;                    // do-statement
   struct Expr_stmt;             // expression-statement
   struct Empty_stmt;            // empty statement -- particular Expr_stmt
   struct For;                   // for-statement
   struct For_in;                // structured for-statement
   struct Goto;                  // goto-statement
   struct Handler;               // exception handler statement
   struct If;                    // if-statement
   struct Labeled_stmt;          // labeled-statement
   struct Return;                // return-statement
   struct Switch;                // switch-statement
   struct While;                 // while-statement

   // -----------------------------------------------
   // -- result of directive constructor constants --
   // -----------------------------------------------
   struct Asm;                   // asm-declaration
   struct Deduction_guide;       // deduction-guide declaration
   struct Static_assert;         // static-assert declaration
   struct Using_declaration;     // using-declaration
   struct Using_directive;       // using-directive
   struct Pragma;                // language-level pragma directive
 
   // -------------------------------------------------
   // -- result of declaration constructor constants --
   // -------------------------------------------------
   struct Alias;                 // alias-declaration
   struct Base_type;             // base-class in class inheritance
   struct Enumerator;            // enumerator in enumeration-declaration
   struct Field;                 // field in union or class declaration
   struct Bitfield;              // bitfield
   struct Fundecl;               // function-declaration
   struct Template;              // template-declaration
   struct Parameter;             // function or template parameter
   struct Typedecl;              // declaration for a type
   struct Var;                   // variable declaration

   // ------------------------
   // -- distinguished node --
   // ------------------------
   struct Translation_unit;     // Translation unit
   struct Module_unit;          // Module unit
   struct Interface_unit;       // Module interface unit
   struct Module;               // module.

   struct Lexicon;              // Interpretation context


   // ----------------------------------
   // -- built-ins, but not constants --
   // ----------------------------------
   struct Global_scope;          // global namespace -- "::"

   // ---------------------------
   // -- Phases of translation --
   // ---------------------------
   // A bitmask type for the various phases of C++ program translation.
   enum class Phases {
      Unknown              = 0x0000,   // Unknown translation phase
      Reading              = 0x0001,   // Opening and reading an input source
      Lexing               = 0x0002,   // Lexical decomposition of input source
      Preprocessing        = 0x0004,   // Macro expansion and friends
      Parsing              = 0x0008,   // Grammatical decomposition of the input source
      Name_resolution      = 0x0010,   // Name lookup
      Typing               = 0x0020,   // Type assignment of expressions
      Evaluation           = 0x0040,   // Compile-time evaluation
      Instantiation        = 0x0080,   // Template instantiation phase
      Code_generation      = 0x0100,   // Code generation phase
      Linking              = 0x0200,   // Linking phase
      Loading              = 0x0400,   // Program loading phase
      Execution            = 0x0800,   // Runtime execution

      Elaboration          = Name_resolution | Typing | Evaluation | Instantiation,
      All                  = ~0x0,
   };


                                // -- Category_node --
   // A list of numerical codes in one-to-one correspondence with
   // IPR node "interface types".  In a sufficiently expressive and
   // efficient type system, we would not need to manually maintain
   // this list.  This can be seen as an optimization of the traditional
   // double-dispatch process for determining the dynamic type of a node.
   enum class Category_code {
#include <ipr/node-category>
   };

                                // -- Various Location Types --
   // C++ constructs span locations.  There are at least four flavours of
   // locations:
   //       (a) physical source location;
   //       (b) logical source location;
   //       (c) physical unit location; and
   //       (d) logical unit location.
   // Physical and logical source locations are locations as witnessed
   // at translation phase 2 (see ISO C++, ยง2.1/1).
   // Physical and logical unit locations are locations as manifest when
   // looking at a translation unit, at translation phase 4.
   //
   // Many IPR nodes will have a source and unit locations.  Instead of
   // storing a source file and unit name as a string in every
   // location data type, we save space by mapping file-names and
   // unit-names to IDs (integers).  That mapping is managed by the Unit
   // instance.

   enum class Line_number : uint32_t { };
   enum class Column_number : uint32_t { };

   struct Basic_location {
      Line_number line = { };
      Column_number column = { };
   };

   enum class File_index : uint32_t { };

   struct Source_location : Basic_location {
      File_index file = { };    // ID of the file
   };

   enum class Unit_index : uint32_t { };

   struct Unit_location : Basic_location {
      Unit_index unit = { };    // ID of the unit
   };

   // -- General structural utility types.

   template<Category_code Cat, class T = Expr>
   struct Category : T {
   protected:
      constexpr Category() : T{ Cat } { }
   };

                                // -- Sequence<> --
   // Often, we use a notion of sequence to represent intermediate
   // abstractions like base-classes, enumerators, catch-clauses,
   // parameter-type-list, etc.  A "Sequence" is a collection abstractly
   // described by its "begin()" and "end()" iterators.  It is made
   // abstract because it may admit different implementations depending
   // on concrete constraints.  For example, a scope (a sequence of
   // declarations, that additionally supports look-up by name) may
   // implement this interface either as a associative-array that maps
   // Names to Declarations (with no particular order) or as
   // vector<Declaration*> (in order of their appearance in programs), or
   // as a much more elaborated data structure.
   template<class T>
   struct Sequence  {
      struct Iterator;          // An iterator is a pair of (sequence,
                                // position).  The position indicates
                                // the particular value referenced in
                                // the sequence.

      // Provide STL-style interface, for use with some STL algorithm
      // helper classes.  Sequence<> is an immutable sequence.
      using value_type = T;
      using reference = const T&;
      using pointer = const T*;
      using Index = std::size_t;
      using iterator = Iterator;

      virtual Index size() const = 0;
      bool empty() const { return not (size() > 0); }
      Iterator begin() const;
      Iterator end() const;
      Iterator position(Index) const;

   protected:
      virtual const T& get(Index) const = 0;
   };

                                // -- Sequence<>::Iterator --
   // This iterator class is as abstract as it could be, for useful
   // purposes.  It forwards most operations to the "Sequence" class
   // it provides a view for.
   template<class T>
   struct Sequence<T>::Iterator {
      using self_type = Sequence<T>::Iterator;
      using value_type = const T;
      using reference = const T&;
      using pointer = const T*;
      using difference_type = ptrdiff_t;
      using Index = typename Sequence<T>::Index;
      using iterator_category = std::bidirectional_iterator_tag;

      Iterator() {}
      Iterator(const Sequence* s, Index i) : seq{ s }, index{ i } { }

      const T& operator*() const
      { return seq->get(index); }

      const T* operator->() const
      { return &seq->get(index); }

      Iterator& operator++()
      {
         ++index;
         return *this;
      }

      Iterator& operator--()
      {
        --index;
        return *this;
      }

      Iterator operator++(int)
      {
         Iterator tmp = *this;
         ++index;
         return tmp;
      }

      Iterator operator--(int)
      {
        Iterator tmp = *this;
        --index;
        return tmp;
      }

      bool operator==(Iterator other) const
      { return seq == other.seq and index == other.index; }

      bool operator!=(Iterator other) const
      { return not(*this == other); }

   private:
      const Sequence* seq { };
      Index index { };
   };

   template<class T>
   inline typename Sequence<T>::Iterator
   Sequence<T>::position(Index i) const
   { return { this, i }; }

   template<class T>
   inline typename Sequence<T>::Iterator
   Sequence<T>::begin() const
   { return { this, 0 }; }

   template<class T>
   inline typename Sequence<T>::Iterator
   Sequence<T>::end() const
   { return { this, size() }; }

                                 // -- Delimiter --
   // Enclosure delimiters of expressions
   enum class Delimiter {
      Nothing,                   // no delimiter
      Paren,                     // "()"
      Brace,                     // "{}"
      Bracket,                   // "[]"
      Angle,                     // "<>"
   };

   // Nesting level of a mapping
   enum class Mapping_level : std::size_t { };

   // Position of a declaration in its declarative region
   enum class Decl_position : std::size_t { };

                                // -- Optional<> --
   // Occasionally, a node has an optional property (e.g. a variable
   // has an optional initializer).  This class template captures
   // that commonality and provides a checked access.
   template<typename T>
   struct Optional {
      Optional(const T* p = nullptr) : ptr { p } { }
      const T& get() const { return *util::check(ptr); }
      bool is_valid() const { return ptr != nullptr; }
      explicit operator bool() const { return is_valid(); }
      template<typename U, bool = std::is_base_of_v<T, U>>
      operator Optional<U>() const { return { ptr }; }
   private:
      const T* ptr;
   };

                                // -- Unary<> --
   // A unary-expression is a specification of an operation that takes
   // only one operand, an expression.  By extension, a unary-node is a
   // node category that is essentially determined only by one node,
   // its "operand".  Usually, such an operand node is a classic expression.
   // Occasionally, it can be a type (e.g. sizeof (T)), we don't want to
   // loose that information, therefore we add a template-parameter
   // (the second) to indicate the precise type of the operand.  The first
   // template-parameter designates the actual node subcategory this class
   // provides an interface for.
   template<class Cat, class Operand = const Expr&>
   struct Unary : Cat {
      using Arg_type = Operand;
      virtual Operand operand() const = 0;
   };


                                // -- Binary<> --
   // In full generality, a binary-expression is an expression that
   // consists in (a) an operator, and (b) two operands.  In Standard
   // C++, the two operands often are of the same type (and if they are not,
   // they are implicitly converted).  In IPR, they need not be
   // of the same type.  This generality allows representations of
   // cast-expressions which are conceptually binary-expressions -- they
   // take a type and an expression.  Also, a function call is
   // conceptually a binary-expression that applies a function to
   // a list of arguments.  By extension, a binary node is any node that
   // is essentially dermined by two nodes, its "operands".
   // As for Unary<> nodes, we indicate the operands' type information
   // through the template-parameters First and Second.
   template<class Cat, class First = const Expr&, class Second = const Expr&>
   struct Binary : Cat {
      using Arg1_type = First;
      using Arg2_type = Second;
      virtual First first() const = 0;
      virtual Second second() const = 0;
   };

                                // -- Ternary<> --
   // Similar to Unary<> and Binary<> categories.  This is for
   // ternary-expressions, or more generally for ternary nodes.
   // An example of a ternary node is a Conditional node.
   template<class Cat, class First = const Expr&,
            class Second = const Expr&, class Third = const Expr&>
   struct Ternary : Cat {
      using Arg1_type = First;
      using Arg2_type = Second;
      using Arg3_type = Third;
      virtual First first() const = 0;
      virtual Second second() const = 0;
      virtual Third third() const = 0;
   };

                                // -- Quaternary --
   // Similar to Unary<>, Binary<> and Ternary<>.  Quaternary nodes are,
   // however rare in diversity.  Examples include function types.
   template<class Cat, class First = const Product&,
            class Second = const Type&, class Third = const Type&,
            class Fourth = const Linkage&>
   struct Quaternary : Cat {
      using Arg1_type = First;
      using Arg2_type = Second;
      using Arg3_type = Third;
      using Arg4_type = Fourth;
      virtual First first() const = 0;
      virtual Second second() const = 0;
      virtual Third third() const = 0;
      virtual Fourth fourth() const = 0;
   };


   // -----------------------------------
   // -- Basic syntactic units: Tokens --
   // -----------------------------------
   // The IPR focuses primarily on semantic aspects of C++ constructs.
   // Certain constructs, such as uninstantiated template definitions,
   // are primarily syntactic with minimal semantic processing.  IPR nodes
   // can fully represent those structurally well-defined syntactic entities.
   // However, C++11 added attributes which are essentially token soups.  These
   // attributes make the IPR interface less abstract than wanted.

   // General classification of tokens, e.g. identifier, number, space, comment, etc.
   enum class TokenCategory : uint8_t { };

   // A numerical value associated with each token.
   enum class TokenValue : uint16_t { };

   struct Lexeme {
      virtual const String& spelling() const = 0;
      virtual const Source_location& locus() const = 0;
   };

   struct Token {
      virtual const Lexeme& lexeme() const = 0;
      virtual TokenValue value() const = 0;
      virtual TokenCategory category() const = 0;
   };

   struct Attribute {
      struct Visitor;
      virtual void accept(Visitor&) const = 0;
   };

   // A simple token used as attribute.
   struct BasicAttribute : Attribute {
      virtual const Token& token() const = 0;
   };

   // An attribute of the form `token1 :: token2'
   struct ScopedAttribute : Attribute {
      virtual const Token& scope() const = 0;
      virtual const Token& member() const = 0;
   };

   // An attribute of the form `token : attribute'.
   struct LabeledAttribute : Attribute {
      virtual const Token& label() const = 0;
      virtual const Attribute& attribute() const = 0;
   };

   // An attribute of the form `f(args)'.
   struct CalledAttribute : Attribute {
      virtual const Attribute& function() const = 0;
      virtual const Sequence<Attribute>& arguments() const = 0;
   };

   // An attribute of the form `attribute...'
   struct ExpandedAttribute : Attribute {
      virtual const Token& expander() const = 0;
      virtual const Attribute& operand() const = 0;
   };

   // An attribute of the form `[[using check: memory(3), type(2)]]'
   struct FactoredAttribute : Attribute {
      virtual const Token& factor() const = 0;
      virtual const Sequence<Attribute>& terms() const = 0;
   };

   // An attribute of the form `[[ expr ]]', where `expr' is the elaboration result
   // of parsing and semantics analysis of the enclosed token sequence.  This is a 
   // common non-standard form of attribute.
   struct ElaboratedAttribute : Attribute {
      virtual const Expr& elaboration() const = 0;
   };

   struct Attribute::Visitor {
      virtual void visit(const BasicAttribute&) = 0;
      virtual void visit(const ScopedAttribute&) = 0;
      virtual void visit(const LabeledAttribute&) = 0;
      virtual void visit(const CalledAttribute&) = 0;
      virtual void visit(const ExpandedAttribute&) = 0;
      virtual void visit(const FactoredAttribute&) = 0;
      virtual void visit(const ElaboratedAttribute&) = 0;
   };

                                // -- DeclSpecifiers --
   enum class DeclSpecifiers : uint32_t {
      None       = 0,
      Register   = 1 << 0,   // Banned from C++17.
      Static     = 1 << 1,
      Extern     = 1 << 2,
      Mutable    = 1 << 3,
      Thread     = 1 << 4,
      StorageClass  = Register | Static | Extern | Mutable | Thread,

      Inline     = 1 << 5,
      Virtual    = 1 << 6,   // also used as storage class specifier
                             // for virtual base subobjects
      Explicit   = 1 << 7,
      Pure       = 1 << 8, 
      FunctionSpecifier = Inline | Virtual | Explicit | Pure,

      Friend     = 1 << 9,
      Typedef    = 1 << 10,

      Public     = 1 << 11,
      Protected  = 1 << 12,
      Private    = 1 << 13,
      AccessProtection = Public | Protected | Private,

      Export     = 1 << 14,  // For exported declarations.
      Constexpr  = 1 << 15,  // C++ 11
      Consteval  = 1 << 16,  // C++20
   };

   constexpr DeclSpecifiers operator|(DeclSpecifiers a, DeclSpecifiers b)
   {
      return DeclSpecifiers(uint32_t(a) | uint32_t(b));
   }

   constexpr DeclSpecifiers& operator|=(DeclSpecifiers& a, DeclSpecifiers b)
   {
      return a = a | b;
   }

   constexpr DeclSpecifiers operator&(DeclSpecifiers a, DeclSpecifiers b)
   {
      return DeclSpecifiers(uint32_t(a) & uint32_t(b));
   }

   constexpr DeclSpecifiers& operator&=(DeclSpecifiers& a, DeclSpecifiers b)
   {
      return a = a & b;
   }

   constexpr DeclSpecifiers operator^(DeclSpecifiers a, DeclSpecifiers b)
   {
      return DeclSpecifiers(uint32_t(a) ^ uint32_t(b));
   }

   constexpr DeclSpecifiers& operator^=(DeclSpecifiers& a, DeclSpecifiers b)
   {
      return a = a ^ b;
   }

   constexpr bool implies(DeclSpecifiers a, DeclSpecifiers b)
   {
      return (a & b) == b;
   }

                                 // -- Lambda_specifiers --
   // Declaration specifiers that can appear on a lambda expression.
   enum class Lambda_specifiers : uint32_t {
      None = 0,
      Mutable    = 1 << 0,
      Constexpr  = 1 << 1,
      Consteval  = 1 << 2,
   };

   // The available modes of lambda captures
   enum class Capture_mode {
      Value,                                    // Default capture by value ("=" squiggle)
      Reference,                                // Default capture by reference ("&" squiggle)
   };

                                // -- Module_name --
   struct Module_name {
      virtual const Sequence<Identifier>& stems() const = 0;
   };

                                // -- Node --
   // Universal base class of all IPR nodes, in the traditional
   // OO design sense.  Its primary purpose is to provide a hook
   // for the Visitor Design Pattern.
   struct Node {
      // This class does not have a declared virtual destructor
      // because we don't plan to have Nodes manage resources, and
      // therefore no deletion through pointers to this base class.

      const Category_code category; // the category the complete node object
                                // belongs to.  In a sufficiently expressive
                                // and efficient type system, we would not
                                // need this member, for it could be read
                                // directly from the type of the object.


      // Hook for visitor classes.
      virtual void accept(Visitor&) const = 0;

   protected:
      // It is an error to create a complete object of this type.
      constexpr Node(Category_code c) : category{ c } { }
   };

                                // -- String --
   // Strings in IPR are immutable, and therefore unified.
   // FIXME: Internal representation should default to UTF-8 encoding.
   struct String : Category<Category_code::String, Node> {
      using iterator = const char*;
      using Index = std::size_t;
      virtual Index size() const = 0;
      virtual iterator begin() const = 0;
      virtual iterator end() const  = 0;
      static const String& empty_string();            // dedicated node for an empty string
   };

                                // -- Comment --
   // This node represents comments, either C-style or BCPL-style.  Notice
   // that the comment delimiters are part of Comment::text.
   struct Comment : Unary<Category<Category_code::Comment, Node>, const String&> {
      Arg_type text() const { return operand(); }
   };

                                // -- Linkage --
   // This node represent language linkage, e.g., "C" in `extern "C"'.
   // Ths ISO standard mandates at least two language linkages: "C" and
   // "C++".  If those were the only language linkage used in practice,
   // then, we would have just used a 2-valued enum.  However, some C++
   // implementations do have support for things like "Java" language
   // linkage and whatnot.  Consequently, the most general representation
   // is adopted.  From ISO C++ point of view, language linkage applies
   // only to function names, variable names, and function types.
   struct Linkage : Unary<Category<Category_code::Linkage, Node>, const String&> {
      Arg_type language() const { return operand(); }
   };

                                // -- Annotation --
   // A pair "(name, value)" used to communicate information
   // between external tools that use IPR.
   struct Annotation : Binary<Category<Category_code::Annotation, Node>,
                              const String&, const Literal&> {
      Arg1_type name() const { return first(); }
      Arg2_type value() const { return second(); }
   };

                                // -- Region --
   // A Region node represents a region of program text.  It is mostly
   // useful for capturing the notion of scope (in Standard C++ sense).
   // In IPR, we're using a generalized notion of Scope (a sequence of
   // declarations).  The  notion of Region helps make precise when
   // some implicit actions like cleanup-ups happen, or nesting of scopes.
   // The sequence of declarations appearing in a Region makes up the
   // Scope of that region.
   struct Region : Category<Category_code::Region, Node> {
      using Location_span = std::pair<Unit_location, Unit_location>;
      virtual const Location_span& span() const = 0;
      virtual const Region& enclosing() const = 0;
      virtual const Scope& bindings() const = 0;
      virtual const Expr& owner() const = 0;
      virtual bool global() const = 0;                   // is this region the global region?
   };

                                // -- Expr --
   // An expression is a sequence of operators and operands that specifies
   // a computation.  Such a computation can be static (constant,
   // object, function, type, template, namespace, concept) or dynamic
   // (object, function).  Every expression has a type.
   struct Expr : Node {
      virtual const Type& type() const = 0;

   protected:
      constexpr Expr(Category_code c) : Node{ c } { }
   };

                                // -- Classic --
   // Classic expressions are those constructed with operators
   // directly expressible in standard C++.  Most of those operators
   // can be overloaded and given user-defined implementation. For
   // instance,  cout << 2, involves a user-defined operator.  The IPR
   // representation is not a function call but, something like
   //
   //                        << ---> implementation
   //                       /  \.
   //                    cout   2
   //
   // where we record the fact that the left-shift operator has a
   // user-defined meaning.  In IPR, we take the general approach that
   // all operators can be given user-defined meanings.  Consequently,
   // we define this class to represent the idea that an expression
   // can have a user-supplied meaning.
   //
   // IPR defines a language that is a superset of C++. The term classic
   // refers to the C++ language.
   struct Classic : Expr {
      // For an operation that is given a user-supplied meaning, retrieve
      // the implementation. In non-templated context this returns a
      // user-supplied declaration. In templated contexts it might return
      // an overload set.
      virtual Optional<Expr> implementation() const = 0;

   protected:
      constexpr Classic(Category_code c) : Expr{ c } { }
   };

                                // -- Name --
   // Standard C++ says that 'a name is a use of identifier to designate
   // an entity'.  In IPR we take the view that a name is a symbol
   // (or combination thereof) interpreted in their most abstract sense,
   // i.e. whose meaning depends on binding contexts (Scopes).
   // That definition accounts for the following (in the standard C++ sense)
   //    - unqualified-id                    -- Identifier
   //    - operator-function-id              -- Operator
   //    - conversion-function-id            -- Conversion
   //    - template-id                       -- Template_id
   //    - type-id                           -- Type_id
   //
   // Most names are introduced by declarations into a Region.
   struct Name : Node {
      // At the moment, this class is empty because there is no
      // interesting operation that could be provided here without
      // imposing too much of implementation details.

   protected:
      constexpr Name(Category_code c) : Node{ c } { }
   };

                                // -- Identifier --
   // An identifier is a sequence of alphanumeric characters starting
   // with either a letter or an underbar ('_').
   struct Identifier : Unary<Category<Category_code::Identifier, Name>, const String&> {
      // The character sequence of this identifier
      Arg_type string() const { return operand(); }
   };

                                // -- Suffix --
   // The suffix of a user-defined literal is essential just an identifier
   // with a distinguished interpretation.
   struct Suffix : Unary<Category<Category_code::Suffix, Name>, const Identifier&> {
      Arg_type name() const { return operand(); }
   };

                                // -- Operator --
   // For a function operator "operator @", "opname()" is the "@"
   // sub-part.  Notice that for the array forms of allocation
   // and deallocation operator functions, this is respectively
   // "new[]" and "delete[]", with no space before, between, or after
   // the square brackets.
   struct Operator : Unary<Category<Category_code::Operator, Name>, const String&> {
      Arg_type opname() const { return operand(); }
   };

                                // -- Conversion --
   // A conversion-function-id is the name of a user-defined
   // conversion function.
   struct Conversion : Unary<Category<Category_code::Conversion, Name>, const Type&> {
      // The type this conversion-function converts values to.
      Arg_type target() const { return operand(); }
   };

                                // -- Template_id --
   // A Template_id is a name of the form
   //    template-expr<template-argument-list>
   // which 'applies' a template to a template-argument list.
   struct Template_id : Binary<Category<Category_code::Template_id, Name>,
                               const Name&, const Expr_list&> {
      Arg1_type template_name() const { return first(); }
      Arg2_type args() const { return second(); }
   };


                                // -- Ctor_name --
   // Standard C++ is not very consistent about constructor
   // name. On one hand, it says constructors do not have names;
   // but on another hand, there are clearly cases where they
   // act as if they had name.  For example, "S::S" designates
   // constructors of class S.  Similarly, if class S has a template
   // constructor then explicit or partial specializations need ways
   // to refer to particular set of specializations.  By consistency
   // with other declarations, and symmetry with destrcutors, we have
   // introduced this node class.
   struct Ctor_name : Unary<Category<Category_code::Ctor_name, Name>, const Type&> {
      Arg_type object_type() const { return operand(); }
   };

                                // -- Dtor_name --
   // This node represent a destructor name of the form "~T", where T
   // is a type.
   struct Dtor_name : Unary<Category<Category_code::Dtor_name, Name>, const Type&> {
      Arg_type object_type() const { return operand(); }
   };
                                // -- Guide_name --
   // This interface class represents the name of a deduction guide.
   // Deduction guides do not have names in Standard C++, and they cannot
   // be found by name lookup.  Yet, they are entities (like templates)
   // that generate compiler-internal instructions (their initializers)
   // that when executed yield deduced template-arguments.  As such, they
   // fit the IPR model of a declaration being an introduction of a name
   // in a scope, with a type and optional initializer.
   struct Guide_name : Unary<Category<Category_code::Guide_name, Name>, const Template&> {
      Arg_type mapping_decl() const { return operand(); }
   };

                                // -- Type_id --
   // This node is used for elaborated expressions that designate types.
   // For example, "const T*" is a Type_id , so is "int (T&)".
   struct Type_id : Unary<Category<Category_code::Type_id, Name>, const Type&> {
      Arg_type type_expr() const { return operand(); }
   };

                                // -- Rname --
   // This is the abstract, alpha-renaming independent, representation of
   // a parameter (of either a function or a template) in its de Brujin
   // level form.  Here we include type in the abstract-name.
   // The "level" is the nesting-depth, starting from 1, of the parameter.
   // the "position" is its position, starting from 0, in the
   // parameter-list at a given level.
   struct Rname : Ternary<Category<Category_code::Rname, Name>,
                          const Type&, Mapping_level, Decl_position> {
      // Although the type() of an Rname is its first operand, we don't define
      // that function here, for it would involve a two indirections to
      // to give the result.  Consequently we define it in the implementation
      // part.
      Arg2_type level() const { return second(); }
      Arg3_type position() const { return third(); }
   };

                                // -- Overload --
   // An overload-set is an expression whose value is the set of all
   // declarations for a name in a given scope.  An overload-set supports
   // look-up by type.  The result of such lookup is the canonical declaration
   // of all declarations with that given type, in that scope.
   struct Overload : Category<Category_code::Overload> {
      virtual Optional<Decl> operator[](const Type&) const = 0;
   };

                                // -- Scope --
   // A "declaration" is a type specification for a name. A "Scope" is
   // a "sequence" of declarations, that additionally supports "lookup"
   // by "Name".  A name may have more than one declarations in a given
   // scope; such a name is said "overloaded".  The result of
   // looking up a name in a scope is a set of all declarations, called
   // an "overload set", for that name in that scope.  An "overload set"
   // is a "sequence" of declarations, that additionally supports
   // lookup by "Type".
   struct Scope : Category<Category_code::Scope> {
      using Iterator = Sequence<Decl>::Iterator;

      // The sequence of declarations this scope contain.
      virtual const Sequence<Decl>& elements() const = 0;

      // Look-up by name returns the overload-set of all declarations,
      // for the subscripting name, contained in this scope.
      virtual Optional<Overload> operator[](const Name&) const = 0;

      // How may declarations are there in this Scope.
      auto size() const { return elements().size(); }

      Iterator begin() const { return elements().begin(); }
      Iterator end() const { return elements().end(); }
   };

                                // -- General types --
   // A type is a collection of constraints and operations that preserve
   // some invariants.  Since a Type is also an Expression, it has a type.
   // A type of a type is an instance of a concept - a constraint.  A type 
   // in IPR has a much broader significance than Standard C++ types 
   // (henceforth called "classic type").  In particular, in IPR, "namespace"
   // is a type. Similarly, an overload-set has a type.
   struct Type : Expr {
      // All types have names.
      virtual const Name& name() const = 0;

   protected:
      constexpr Type(Category_code c) : Expr{ c } { }
   };

   // cv-qualifiers are actually type operators.  Much of these operators
   // currently make sense only for classic type -- although it might
   // be interesting to explore the notion of pointer to overload-set
   // or reference to such an expression.
   enum class Type_qualifier : uint8_t {
      None             = 0,
      Const            = 1 << 0,
      Volatile         = 1 << 1,
      Restrict         = 1 << 2        // not standard C++
   };

   constexpr Type_qualifier
   operator|(Type_qualifier a, Type_qualifier b)
   {
      return Type_qualifier(uint8_t(a) | uint8_t(b));
   }

   inline Type_qualifier&
   operator|=(Type_qualifier& a, Type_qualifier b)
   {
      return a = a | b;
   }

   constexpr Type_qualifier
   operator&(Type_qualifier a, Type_qualifier b)
   {
      return Type_qualifier(uint8_t(a) & uint8_t(b));
   }

   inline Type_qualifier&
   operator&=(Type_qualifier& a, Type_qualifier b)
   {
      return a = a & b;
   }

   constexpr Type_qualifier
   operator^(Type_qualifier a, Type_qualifier b)
   {
      return Type_qualifier(uint8_t(a) ^ uint8_t(b));
   }

   inline Type_qualifier&
   operator^=(Type_qualifier& a, Type_qualifier b)
   {
      return a = a ^ b;
   }

   constexpr bool implies(Type_qualifier a, Type_qualifier b)
   {
      return (a & b) == b;
   }

                                // -- Array --
   // An array-type describes object expressions that designate C-style
   // homogenous object containers that meet the random-access
   // requirements.  When an array-type is declared with unspecified
   // bound, "bound()" returns a null-expression.
   // An alternate design choice would have been to have a predicate
   // "has_unknown_bound()", which when true would make "bound()" throw
   // an exception if accessed.
   struct Array : Binary<Category<Category_code::Array, Type>, const Type&> {
      Arg1_type element_type() const { return first(); }
      Arg2_type bound() const        { return second(); }
   };

                                // -- As_type --
   // This node represents the use of a general expression as
   // a type.  Such situation arises in cases where a declaration
   // node can be used to designate a type, as in:
   //    struct S;
   //    typedef int count;
   //    typename T::size_type s = 90;
   //    template<typename T, T t> ...
   // Some C++ implementations define "extended built-in" types with
   // language linkage, e.g. `extern "Java"' or `extern "Fortran"', for
   // interoperating with other languages.  The current representation
   // includes language linkage as integral part of As_type.
   struct As_type : Binary<Category<Category_code::As_type, Type>,
                           const Expr&, const Linkage& > {
      Arg1_type expr() const { return first(); }
      Arg2_type lang_linkage() const { return second(); }
   };

                                // -- Decltype --
   // This node represents query for the "generalized declared type"
   // of an expression.
   struct Decltype : Unary<Category<Category_code::Decltype, Type>, const Expr&> {
      Arg_type expr() const { return operand(); }
   };

                                // -- Tor --
   // A node of this class represents a Type for either a constructor or a destructor.
   // Formally, ISO C++ does not assign types to those special functions; however, a
   // type-based representation of C++ semantics must assign types to such declarations.
   // Although a low-level (e.g. ABI-level) representation of a contructor and a destructor
   // may look at them as just some regular function, and assign them a Function type,
   // the higher level semantics of C++ is best served by a dedicated type to abstract
   // over ABI interpretation.
   struct Tor : Ternary<Category<Category_code::Tor, Type>,
                        const Expr&, const Type&, const Linkage&> {
      // The parameter-list to a tor type.  Always empty for a Standard C++ destructor.
      Arg1_type source() const { return first(); }
      // The exception-specification for this tor type.
      Arg2_type throws() const { return second(); }
      // The language linkage for this to type.  Default is "C++".
      Arg3_type lang_linkage() const { return third(); }
   };

                                // -- Function --
   // This node class represents a Type that describes an expression
   // that refers to a function.  In full generality, a template
   // is a also a function (it describes Type-valued functions);
   // however, we've made a special node for template.  ISO C++ specifies
   // that function types have language linkages and two function types
   // with different language linkages are different.
   struct Function : Quaternary<Category<Category_code::Function, Type>> {
      // Parameter-type-list of a function of this type.  In full
      // generality, this also describes template signature.
      Arg1_type source() const { return first(); }

      // return-type
      Arg2_type target() const { return second(); }

      // list of exception types a function of this type may throw
      Arg3_type throws() const { return third(); }

      // The language linkage for this function type.  For most function
      // types, it is C++ -- for it is the default.
      Arg4_type lang_linkage() const { return fourth(); }
   };

                                // -- Pointer --
   // A pointer-type is type that describes an Address node.
   struct Pointer : Unary<Category<Category_code::Pointer, Type>, const Type&> {
      // The type of the entity whose address an object of this
      // type may hold.
      Arg_type points_to() const { return operand(); }
   };

                                // -- Product --
   // A Product represents a Cartesian product of Types.  Pragmatically,
   // it may be viewed as a Sequence of Types.  It is a Type.
   struct Product : Unary<Category<Category_code::Product, Type>, const Sequence<Type>&> {
      using Index = std::size_t;
      Arg_type elements() const { return operand(); }
      auto size() const { return elements().size(); }
      const Type& operator[](Index i) const { return *elements().position(i); }
   };

                                // -- Ptr_to_member --
   // This is for pointer-to-member type, e.g. int A::* or void (A::*)().
   // A pointer to member really is not a pointer type, it is much closer
   // a pair of a type and offset that usual pointer types.
   struct Ptr_to_member : Binary<Category<Category_code::Ptr_to_member, Type>,
                                 const Type&, const Type&> {
      Arg1_type containing_type() const { return first(); }
      Arg2_type member_type() const { return second(); }
   };

                                // -- Qualified --
   // A cv-qualified type.  Representing a cv-qualified type with all
   // available information attainable in at most one indirection is
   // very tricky. Consequently, we currently represents a cv-qualified
   // type with a separate node as a binary operator.  Notice that we
   // maintain the invariant
   //     Qualified(cv2, Qualified(cv1, T)) = Qualified(cv1 | cv2, T)
   // In particular, the Qualified::main_variant is never a Qualified node.
   // We also maintain the invariant that Qualified::qualifiers is never
   // Type::None, consequently it is an error to attempt to create such a node.
   struct Qualified : Binary<Category<Category_code::Qualified, Type>,
                             ipr::Type_qualifier, const Type&> {
      Arg1_type qualifiers() const { return first(); }
      Arg2_type main_variant() const { return second(); }
   };

                                // -- Reference --
   // A reference-type describes an expression that acts like an alias
   // for a object or function.  However, unlike a pointer-type, it is
   // not an object-type.
    struct Reference : Unary<Category<Category_code::Reference, Type>, const Type&> {
       // The type of the object or function an expression of this
       // type refers to.
       Arg_type refers_to() const { return operand(); }
    };

                                // -- Rvalue_reference --
   // An rvalue-reference-type to support move semantics.
    struct Rvalue_reference : Unary<Category<Category_code::Rvalue_reference, Type>,
                                    const Type&> {
       // The type of the object or function an expression of this
       // type refers to.
       Arg_type refers_to() const { return operand(); }
    };

                                // -- Sum --
   // A Sum type represents a distinct union of types.  This is currently
   // used only for dynamic exception specification in Function type.
   struct Sum : Unary<Category<Category_code::Sum, Type>, const Sequence<Type>&> {
      using Index = std::size_t;
      Arg_type elements() const { return operand(); }
      auto size() const { return elements().size(); }
      const Type& operator[](Index i) const { return *elements().position(i); }
   };

                                // -- Forall --
   // This represents a universally quantified type, parameterized by any compile-time sort;
   // that is, all values for the parameters must designate compile-time entities.
   // It is useful for representing the type of a template declaration, and more.  In the near future,
   // when "concepts" are integrated, it will become a Ternary node where the
   // third operand will represent the "where-clause".
   struct Forall : Binary<Category<Category_code::Forall, Type>,
                            const Product&, const Type&> {
      // The constraints or types of the template-parameters.
      const Product& source() const { return first(); }
      // The type of the instantiation result.
      const Type& target() const { return second(); }
   };

                                // -- Udt --
   // Base class for user-defined types Nodes -- factor out common properties.
   template<typename T>
   struct Udt : Type {
      // The general interface to members of this user-defined type.
      using Member = T;
      // The region delimited by the definition of this Udt.
      virtual const Region& region() const = 0;
      const Scope& scope() const { return region().bindings(); }
      virtual const Sequence<Member>& members() const = 0;

   protected:
      // It is an error to create a node of this type.
      constexpr Udt(Category_code c) : Type{ c } { }
   };

                                // -- Namespace --
   // A Standard C++ namespace is a compile-time accumulative singleton variable
   // that is initialized with a sequence of declarations.  The type of 
   // such a variable is given by an IPR "namespace" type.
   struct Namespace : Category<Category_code::Namespace, Udt<Decl>> {
      const Sequence<Decl>& members() const final { return scope().elements(); }
   };

                                // -- Class --
   struct Class : Category<Category_code::Class, Udt<Decl>> {
      const Sequence<Decl>& members() const final { return scope().elements(); }
      virtual const Sequence<Base_type>& bases() const = 0;
   };

                                // -- Union --
   struct Union : Category<Category_code::Union, Udt<Decl>> {
      const Sequence<Decl>& members() const final { return scope().elements(); }
   };

                                // -- Enum --
   // An enumeration is an object-type whose members are named constants
   // the definitions of which as part of the definition of the enumeration
   // itself.  By historical accident, enumerators are not "properly scoped".
   struct Enum : Category<Category_code::Enum, Udt<Enumerator>> {
      enum class Kind : uint8_t {     // The kind of enum.
         Legacy,                      // traditional C-style enum
         Scoped                       // scoped enum (C++11)
      };
      virtual Kind kind() const = 0;
   };

                                // -- Auto --
   struct Auto : Category<Category_code::Auto, Type> {
   };


   // A capture is a description of how a local entity is referenced in a lambda expression.
   // It is essentially a pair (Capture_mode, Decl) where the first component tells how the 
   // entity is referenced (by value or by reference), and a declaration that specifies the 
   // declarative semantic properties of the captured entity.
   // Note: A Capture should not be confused with a Capture_specification: the specification
   //       is a prescription of how an entity should be captured (either explicitly or implicitly) 
   //       in a lambda, whereas a capture is a result of executing that prescription.
   struct Capture {
      virtual Capture_mode mode() const = 0;
      virtual const Decl& entity() const = 0;
   };

                                // -- Closure --
   // A closure type is the type of a lambda expression, which ISO C++ confusingly requires
   // to be a non-union class type.  The logical representation in the IPR has it as a distinct
   // (generative) user-defined type whose members are captures.   Each lambda expression has
   // its own unique type, even if its members would be otherwise the same.
   struct Closure : Category<Category_code::Closure, Udt<Capture>> { };

                                // -- Phantom --
   // This nodes represents a missing expression, as in the "bound" of an array type with
   // unknown bound, e.g. in "unsigned char charset[];", or in an empty expression-statement.
   // We do not unify Phantom expressions, as two arrays with
   // unknown bounds may not designate the same type.
   struct Phantom : Category<Category_code::Phantom> { };


                                // -- Eclipsis --
   // Representation of the `...' in a unary fold, e.g. `... + e'.
   // Note: that `...' is not the pack expansion operator.  There is no operand to the `...' here.
   // While the syntax looks the same, the meaning is really different.  It stands for something
   // was omitted, hence the name.
   struct Eclipsis : Category<Category_code::Eclipsis> { };

                                 // -- This --
   // Representation of the `this' implicit parameter for non-static member functions.
   // An earlier design sought to treat `this' no different from any other function parameter declaration, in part
   // to account for multimethods and uniform function call syntax in the same framework.  The current
   // design makes `this' explicit in the semantics graph in part based on recent ISO C++ extensions.
   // The `this' parameter used to make sense only in the context of non-static member functions, so its
   // enclosing context was always a function declaration.  Recent versions of C++ introduced default initializers
   // for non-static data members that can make use of `this', so the function declaration context has to be
   // inferred based on the constructor that makes uses of the default initializer and is completely unknown at
   // point of the specification of the default member initializer.
   struct This : Category<Category_code::This> {
      virtual Optional<Decl> context() const = 0;  // declaration of the enclosing member function, if any.
    };

   // Semantic description of the variety of lambda capture specifications:
   //   - default captures: indicated by the squiggles "=" (by value), and "&" (by reference) at source level
   //   - implicit object: indicated by "this" (by reference), and "*this" (by value) at source level
   //   - named symbols: local enclosing variable, and locally introduced variable (with initializer) at source level
   struct Capture_specification {
      struct Default;                           // default lambda capture specification
      struct Implicit_object;                   // capture mode of implicit object
      struct Named;                             // named simple capture; base of Simple and With_initializer
      struct Enclosing_local;                   // simply named captured local entity
      struct Binding;                           // capture with initialization
      struct Expansion;                         // expansion of a lambda capture

      struct Visitor;
      virtual void accept(Visitor&) const = 0;
   };

                                // -- Lambda --
   struct Lambda : Category<Category_code::Lambda> {
      virtual const Closure& type() const override = 0;           // a lambda is of a (unique) closure type
      virtual Optional<Type> target() const = 0;                  // return type, optionally specified at source level
      virtual const Parameter_list& parameters() const = 0;
      virtual Optional<Expr> requirement() const = 0;             // declaration constraint possibly involving parameters
      virtual const Expr& result() const = 0;                     // body of the lambda
      virtual const Sequence<Attribute>& attributes() const = 0;  // optional attribute-list applying to the lambda
      virtual Optional<Expr> eh_specification() const = 0;
      virtual Lambda_specifiers specifiers() const = 0;
      virtual const Sequence<Capture_specification>& captures() const = 0;
   };

   // Default lambda capture specification
   struct Capture_specification::Default : Capture_specification {
      virtual Capture_mode mode() const = 0;
   };

   // Lambda capture specification of the implicit object in a non-static member context.
   // The designation of the capture is defined by how(), where:
   //   - Capture_mode::Reference means 'this'
   //   - Capture_mode::Value means '*this'
   // Note: an alternative design is to introduced a distinct enum for representing the
   //       designation of the implicit object (say 'This' and 'Self), but that would
   //       have just obscured the fundamental semantics correspondence.
   struct Capture_specification::Implicit_object : Capture_specification {
      virtual Capture_mode how() const = 0;
   };

   // Base of lambda captures designated by an given name.
   struct Capture_specification::Named : Capture_specification {
      virtual const Identifier& name() const = 0;
      virtual Capture_mode mode() const = 0;
   };

   // Lambda capture referencing a local entity from the enclosing context.
   struct Capture_specification::Enclosing_local : Capture_specification::Named {
      virtual const Decl& declaration() const = 0;
   };

   // Lambda capture introducing an alias bound to the result of evaluating
   // an expression in the (local) context of the lambda body.
   struct Capture_specification::Binding : Capture_specification::Named {
      virtual const Expr& initializer() const = 0;
   };

   // Lambda capture expansion of either an enclosing variable pack, or a local binding pack.
   struct Capture_specification::Expansion : Capture_specification {
      virtual const Named& what() const = 0;
   };

   struct Capture_specification::Visitor {
      virtual void visit(const Default&) = 0;
      virtual void visit(const Implicit_object&) = 0;
      virtual void visit(const Enclosing_local&) = 0;
      virtual void visit(const Binding&) = 0;
      virtual void visit(const Expansion&) = 0;
   };

                                // -- Symbol --
   // Representation of self-evaluating (generalized) expressions, i.e. irreducible expressions.
   // That includes builtin types, as well as designated special values such as `nullptr'.
   // Note: A symbol is uniquely identified by the pair (name, type), so a symbol can be `overloaded'.
   // Symbol nodes are unified, as they are self-evaluating, e.g. core values.
   struct Symbol : Unary<Category<Category_code::Symbol>, const Name&> {
      const Name& name() const { return operand(); }
   };

                                // -- Address --
   // Address-of expression -- "&expr"
   struct Address : Unary<Category<Category_code::Address, Classic>> { };

                                // -- Array_delete --
   // Array-form of delete-expression --  "delete[] p"
   struct Array_delete : Unary<Category<Category_code::Array_delete, Classic>> {
      const Expr& storage() const { return operand(); }
   };

                                // -- Complement --
   // Complement-expression -- "~expr"
   struct Complement : Unary<Category<Category_code::Complement, Classic>> { };

                                // -- Delete --
   // Delete-expression -- "delete p"
   struct Delete : Unary<Category<Category_code::Delete, Classic>> {
      const Expr& storage() const { return operand(); }
   };

                                // -- Demotion --
   // Integral or floating point conversion
   struct Demotion : Unary<Category<Category_code::Demotion>> { };

                                // -- Deref --
   // Dereference-expression -- "*expr"
   struct Deref : Unary<Category<Category_code::Deref, Classic>> { };

                                // -- Enclosure --
   // Expresion enclosed in matching pair of delimiters.  This might seem purely
   // syntactical but it also has semantic implications, like when an
   // argument-dependent lookup should be done or not, or order of evaluation,the accuracy
   // of an expression evaluation.
   // Note: an empty brace-init translates to a brace enclosure of a Phantom node.
   struct Enclosure : Unary<Category<Category_code::Enclosure>> {
      virtual Delimiter delimiters() const = 0;
      const Expr& expr() const { return operand(); }
   };

                                // -- Expr_list --
   // A sequence of expressions "e1, e2, ..., eN".  This form of expression
   // is a tuple of expressions.  In particular, an Expr_list is different
   // from a Comma expression -- where each sub-expression is evaluated,
   // discarded except the last one.  The type of an Expr_list
   // is a Product.
   struct Expr_list : Unary<Category<Category_code::Expr_list>, const Sequence<Expr>&> {
      using Index = std::size_t;
      Arg_type elements() const { return operand(); }
      auto size() const { return elements().size(); }
   };

                                // -- Alignof --
   //  Alignment query of a type, or any expression.
   struct Alignof : Unary<Category<Category_code::Alignof>> { };

                                // -- Sizeof --
   // sizeof-expression -- "sizeof expr" or "sizeof (int)"
   struct Sizeof : Unary<Category<Category_code::Sizeof>> { };

                                // -- Args_cardinality --
   struct Args_cardinality : Unary<Category<Category_code::Args_cardinality>> { };

                                // -- Noexcept --
   struct Noexcept : Unary<Category<Category_code::Noexcept>> { };

                                // -- Typeid --
   // typeid-expression -- "typeid (expr)", or "typeid (int)"
   struct Typeid : Unary<Category<Category_code::Typeid>> { };

                                // -- Id_expr --
   // This node represents use of a name to designate an entity.
   // In general, names are introduced by a declaration.  In a well-formed
   // fully elaborated program, a use of name refers to exactly one declaration.
   // However, in a partially elaborated program (e.g. a template definition)
   // a dependent name may refer to zero, one, or many (overloaded) declarations.
   struct Id_expr : Unary<Category<Category_code::Id_expr, Expr>, const Name&> {
      // The set of declarations the name refers to, at the elaboration point.
      virtual Optional<Expr> resolution() const = 0;

      Arg_type name() const { return operand(); }
   };

                                // -- Label --
   // label-expression.  Appears in goto-statements.
   struct Label : Unary<Category<Category_code::Label>, const Identifier&> {
      Arg_type name() const { return operand(); }
   };

                                // -- Materialization --
   // Temporary materialization
   struct Materialization : Unary<Category<Category_code::Materialization>> { };

                                // -- Not --
   // logical-not-expression -- "!expr"
   struct Not : Unary<Category<Category_code::Not, Classic>> { };

                                // -- Post_decrement --
   // post-decrement-expression -- "expr--".
   struct Post_decrement : Unary<Category<Category_code::Post_decrement, Classic>> { };

                                // -- Post_increment --
   // post-increment-expression -- "expr++".
   struct Post_increment : Unary<Category<Category_code::Post_increment, Classic>> { };

                                // -- Pre_decrement --
   // pre-decrement-expression -- "--expr".
   struct Pre_decrement : Unary<Category<Category_code::Pre_decrement, Classic>> { };

                                // -- Pre_increment --
   // pre-increment-expression -- "++expr".
   struct Pre_increment : Unary<Category<Category_code::Pre_increment, Classic>> { };

                                // -- Promotion --
   // Integral or floating point promotion -- "(int)'2'"
   struct Promotion : Unary<Category<Category_code::Promotion>> { };

                                // -- Construction --
   // An expression of the form "T(e1, e2, .. en)" or "T{e1, e2, .. en}"
   // where "T" is a type and "ei"s are expressions.  This is not a function
   // call -- although syntactically it looks like so.  "T" will
   // be the `type()' of this expression.
   // The contructor selected for the construction operation is indicated
   // by implementation, which is inherited from Classic. When the enclosure
   // is a singleton, the node can also denote a functional cast expression.
   struct Construction : Unary<Category<Category_code::Construction, Classic>,
                               const Enclosure&> {
      // The sequence of arguments used for this construction
      Arg_type arguments() const { return operand(); }
   };

                                // -- Read --
   // Lvalue-to-rvalue conversion -- "= var"
   struct Read : Unary<Category<Category_code::Read>> { };

                                // -- Throw --
   // A node that represents a C++ expression of the form `throw ex'.
   // As a special case, when exception() is a null-expression, then
   // this node represents the flow-control "throw;", which actually
   // could be represented by a dedicated statement node, Rethrow for
   // instance.
   struct Throw : Unary<Category<Category_code::Throw, Classic>> {
      const Expr& exception() const { return operand(); }
   };

                                // -- Unary_minus --
   // unary-minus-expression -- "-expr"
   struct Unary_minus : Unary<Category<Category_code::Unary_minus, Classic>> { };

                                // -- Unary_plus --
   // unary-plus-expression -- "+expr"
   struct Unary_plus : Unary<Category<Category_code::Unary_plus, Classic>> { };

                                // -- Expansion --
   // Pack expansion.  The operand can be both a classic expression
   // or a type.  Standard C++ does not permit overloading of expansion
   // operator, but the general IPR model here allows it.
   struct Expansion : Unary<Category<Category_code::Expansion, Classic>> { };

                                // -- Rewrite --
   // Various ISO C++ syntactic constructs are defined - unwwisely -
   // via translation to more elaborate sequences of tokens or parse trees.
   // The `source()` is the construct as written in the input source code, and the
   // `target()` is the internal expression giving meaning to the source.
   struct Rewrite : Binary<Category<Category_code::Rewrite>> {
      const Expr& source() const { return first(); }
      const Expr& target() const { return second(); }
      const Type& type() const final { return second().type(); }
   };

                                // -- Member_selection<> --
   // This class factorizes the commonalities of various object member
   // selection operation.
   template<Category_code Cat>
   struct Member_selection : Binary<Category<Cat, Classic>> {
      const Expr& base() const { return this->first(); }
      const Expr& member() const { return this->second(); }
   };

                                // -- Cast_expr<> --
   // This classes factorizes the commonalities of various cast-expressions
   template<Category_code Cat>
   struct Cast_expr : Binary<Category<Cat, Classic>, const Type&> {
      // The type() of a cast expression is its first() operand.  However,
      // we do not define (override) that member here, as it implies two
      // indirections to get the information.  Therefore, it is better
      // to define it at the implementation side where we have all the bits
      // necessary to make it a single indirection.

      const Expr& expr() const { return this->second(); }
   };

                                // -- Scope_ref --
   // A qualified name of the form "scope::member".
   // Although the scope resolution operator ('::') in this expression
   // cannot be overloaded in standard C++ (yet), it is conceptually
   // dual to the dot operator, for which overloading has been
   // suggested multiple time with an operational model.  Consequently,
   // a qualified name is modelled as a classic expression.
   struct Scope_ref : Binary<Category<Category_code::Scope_ref, Classic>> {
      Arg1_type scope() const  { return first(); }
      Arg2_type member() const { return second(); }
   };

                                // -- Plus --
   // Addition-expression -- "a + b"
   struct Plus : Binary<Category<Category_code::Plus, Classic>> { };

                                // -- Plus_assign --
   // In-place addition-expression -- "a += b"
   struct Plus_assign : Binary<Category<Category_code::Plus_assign, Classic>> { };

                                // -- And --
   // Logical-and-expression -- "a && b"
   struct And : Binary<Category<Category_code::And, Classic>> { };

                                // -- Array_ref --
   // This is for an expression that designate a particular slot
   // in an array expression `array[slot]'.
   struct Array_ref : Member_selection<Category_code::Array_ref> { };

                                // -- Arrow --
   // This node type models object member selection, based on pointer,
   // using the arrow-notation.  See `Dot'.
   struct Arrow : Member_selection<Category_code::Arrow> { };

                                // -- Arrow_star --
   // Member selection through pointer to member -- "p->*"
   struct Arrow_star : Member_selection<Category_code::Arrow_star> { };

                                // -- Assign --
   // Assignment-expression -- "a = b"
   struct Assign : Binary<Category<Category_code::Assign, Classic>> { };

                                // -- Bitand --
   // Bit-and-expression -- "a & b"
   struct Bitand : Binary<Category<Category_code::Bitand, Classic>> { };

                                // -- Bitand_assign --
   // In-place bit-and-expression -- "a &= b"
   struct Bitand_assign : Binary<Category<Category_code::Bitand_assign, Classic>> { };

                                // -- Bitor --
   // Bit-or expression -- "a | b"
   struct Bitor : Binary<Category<Category_code::Bitor, Classic>> { };

                                // -- Bitor_assign --
   // In-place bit-or-expression -- "a |= b"
   struct Bitor_assign : Binary<Category<Category_code::Bitor_assign, Classic>> { };

                                // -- Bitxor --
   // Exclusive bit-or-expression -- "a ^ b"
   struct Bitxor : Binary<Category<Category_code::Bitxor, Classic>> { };

                                //  -- Bitxor_assign --
   // In-place exclusive bit-or-expression -- "a ^= b"
   struct Bitxor_assign : Binary<Category<Category_code::Bitxor_assign, Classic>> { };

                                //  -- Cast --
   // An expression of the form "(type) expr", representing the
   // old-style/C-style cast.
   struct Cast : Cast_expr<Category_code::Cast> { };

                                // -- Call --
   // A function call with an argument list.  Notice that in the abstract
   // this is not really different from an Template_id.  However, having
   // a separate node means less clutter in codes.
   struct Call : Binary<Category<Category_code::Call, Classic>,
                         const Expr&, const Expr_list&> {
      Arg1_type function() const  { return first(); }
      Arg2_type args() const { return second(); }
   };

                                // -- Coercion --
   // A generalized type conversion either built-in to the language or
   // programmatically defined by either constructors or conversion
   // functions.
   struct Coercion : Binary<Category<Category_code::Coercion, Classic>, const Expr&, const Type&> {
      Arg1_type expr() const { return first(); }
      Arg2_type target() const { return second(); }
   };

                                // -- Comma --
   // comma-expression -- "a, b"
   struct Comma : Binary<Category<Category_code::Comma, Classic>> { };

                                // -- Const_cast --
   // const_cast-expression -- "const_cast<type>(expr)".
   struct Const_cast : Cast_expr<Category_code::Const_cast> { };

                                // -- Div --
   // Division-expression -- "a / b"
   struct Div : Binary<Category<Category_code::Div, Classic>> { };

                                //  -- Div_assign --
   // In-place division-expression -- "a /= b"
   struct Div_assign : Binary<Category<Category_code::Div_assign, Classic>> { };

                                // -- Dot --
   // This node type represents a member selection on object using
   // the dot-notation "object.member": both "object" and "member"
   // can be general expressions.
   struct Dot : Member_selection<Category_code::Dot> { };

                                // -- Dot_star --
   // An expression of the form "object.*pm".
   struct Dot_star : Member_selection<Category_code::Dot_star> { };

                                // -- Dynamic_cast --
   // An expression of the from "dynamic_cast<type>(expr)".
   struct Dynamic_cast : Cast_expr<Category_code::Dynamic_cast> { };

                                // -- Equal --
   // Equality-comparison-expression -- "a == b"
   struct Equal : Binary<Category<Category_code::Equal, Classic>> { };

                                // -- Greater --
   // greater-comparison-expression -- "a > b"
   struct Greater : Binary<Category<Category_code::Greater, Classic>> { };

                                // -- Greater_equal --
   // greater-or-equal-comparison-expression -- "a >= b"
   struct Greater_equal : Binary<Category<Category_code::Greater_equal, Classic>> { };

                                // -- Less --
   // less-comparison-expression -- "a < b"
   struct Less : Binary<Category<Category_code::Less, Classic>> { };

                                // -- Less_equal --
   // less-equal-comparison-expression -- "a <= b"
   struct Less_equal : Binary<Category<Category_code::Less_equal, Classic>> { };

                                // -- Literal --
   // An IPR literal is just like a standard C++ literal.
   struct Literal : Binary<Category<Category_code::Literal, Classic>,
                           const Type&, const String&> {
      // See comments for the cast operators regarding type().

      // The textual representation of this literal as it appears
      // in the program text.
      Arg2_type string() const { return second(); }
   };

                                // -- Binary_fold --
   // Representation of a binary fold expression, e.g. `(x + ... + y)'.
   // The first() operand designates `x', and the second() operand designates `y'.
   // The operation() is the category code for the operation being folded.
   struct Binary_fold : Binary<Category<Category_code::Binary_fold, Classic>> {
      virtual Category_code operation() const = 0;
   };

                                // -- Mapping --
   // This node represents a parameterized expression.
   // Its type is a Function in case of parameterized classic expression,
   // and Forall otherwise.
   struct Mapping : Category<Category_code::Mapping> {
      virtual const Parameter_list& parameters() const = 0;
      virtual const Type& target() const = 0;
      virtual const Expr& result() const = 0;
   };

                                // -- Member_init --
   // Node that represent a member initialization, in constructor
   // definition.
   struct Member_init : Binary<Category<Category_code::Member_init>> {
      Arg1_type member() const { return first(); }
      Arg2_type initializer() const { return second(); }
   };

                                // -- Minus --
   // Subtraction-expression -- "a - b"
   struct Minus : Binary<Category<Category_code::Minus, Classic>> { };

                                //  -- Minus_assign --
   // In-place subtraction-expression -- "a -= b".
   struct Minus_assign : Binary<Category<Category_code::Minus_assign, Classic>> { };

                                // -- Modulo --
   // Modulo-expression -- "a % b"
   struct Modulo : Binary<Category<Category_code::Modulo, Classic>> { };

                                // -- Modulo_assign --
   // In-place modulo-expression -- "a %= b"
   struct Modulo_assign : Binary<Category<Category_code::Modulo_assign, Classic>> { };

                                // -- Mul --
   // Multiplication-expression -- "a * b"
   struct Mul : Binary<Category<Category_code::Mul, Classic>> { };

                                // -- Mul_assign --
   // In-place multiplication-expression -- "a *= b"
   struct Mul_assign : Binary<Category<Category_code::Mul_assign, Classic>> { };

                                   // -- Narrow --
   // Checked base to derived class conversion. This is always a non-implicit
   // conversion and exists to add additional semantic context to otherwise
   // explicit conversion nodes.
   struct Narrow : Binary<Category<Category_code::Narrow>, const Expr&, const Type&> {

      Arg1_type expr() const { return first(); }
      Arg2_type derived() const { return second(); }
   };

                                // -- Not_equal --
   // Inequality-comparison-expression -- "a != b"
   struct Not_equal : Binary<Category<Category_code::Not_equal, Classic>> { };

                                // -- Or --
   // logical-or-expression -- "a || b"
   struct Or : Binary<Category<Category_code::Or, Classic>> { };

                                // -- Pretend --
   // Generalization of bitcast and reinterpret cast
   struct Pretend : Binary<Category<Category_code::Pretend>, const Expr&, const Type&> {
      Arg1_type expr() const { return first(); }
      Arg2_type target() const { return second(); }
   };

                                // -- Qualification --
   // A conversion that add cv-qualifiers
   struct Qualification : Binary<Category<Category_code::Qualification>, const Expr&, Type_qualifier> {
      Arg1_type expr() const { return first(); }
      Arg2_type qualifier() const { return second(); }
   };

                                // -- Reinterpret_cast --
   // An expression of the form "reinterpret_cast<type>(expr)"
   struct Reinterpret_cast : Cast_expr<Category_code::Reinterpret_cast> { };

                                // -- Lshift --
   // left-shift-expression -- "a << b"
   struct Lshift : Binary<Category<Category_code::Lshift, Classic>> { };

                                // -- Lshift_assign --
   // In-place left-shift-expression -- "a <<= b".
   struct Lshift_assign : Binary<Category<Category_code::Lshift_assign, Classic>> { };

                                // -- Rshift --
   // Right-shift-expression -- "a >> b"
   struct Rshift : Binary<Category<Category_code::Rshift, Classic>> { };

                                // -- Rshift_assign --
   // In-place right-shift-expression -- "a >>= b"
   struct Rshift_assign : Binary<Category<Category_code::Rshift_assign, Classic>> { };

                                // -- Static_cast --
   // An expression of the form "static_cast<type>(expr)".
   struct Static_cast : Cast_expr<Category_code::Static_cast> { };

                                // -- Widen --
   // Derived to base class conversion
   struct Widen : Binary<Category<Category_code::Widen>, const Expr&, const Type&> {
      Arg1_type expr() const { return first(); }
      Arg2_type base() const { return second(); }
   };

                                // -- Where --
   // An expression referencing declarations or restrictions, local to that expression.
   // The expressions or declarations in `attendant()` are evaluated first, and then
   // `main()` is evaluated in the dynamic evaluation cone established by `attendant()`.
   // As usual, variables declared by bindings in `attendant()` are destructed in reverse 
   // order of declarations at the end of their scopes, which occur after the complete
   // evaluation of `main()`.
   // Note: An `attendant()` of type `Scope` indicates that the where-expression introduces
   //       local bindings.
   struct Where : Binary<Category<Category_code::Where>> {
      const Expr& main() const { return first(); }
      const Expr& attendant() const { return second(); }
      const Type& type() const final { return main().type(); }
   };

                                // -- New --
   // This node represents a new-expression:
   //    ::_opt new new-placement_opt new-type-id new-initializer_opt
   //    ::_opt new new-placement_opt ( type-id ) new-initializer_opt
   // Semantically, this has a binary structure where the first operand
   // is the placement-list, and the second operand is a construction expression
   // that indicates the new-type-id or the type-id coupled with the new-initializer if any.
   // When the new-initializer is missing, the Enclosure of the Contruction has no delimiter
   // and the arguments of the Enclosure is a Phantom node.
   // The allocator function is indicated by the implementation().
   struct New : Binary<Category<Category_code::New, Classic>,
                       Optional<Expr_list>, const Construction&> {
      // This predicate holds if the new-expression explicitly requested a global allocator.
      virtual bool global_requested() const = 0;
      Optional<Expr_list> placement() const { return first(); }
      const Construction& initializer() const { return second(); }
   };

                                // -- Conditional --
   // This represents the C++ ternary operator ?:.  In principle, it is redundant
   //  with both If and Switch nodes from semantics point of view.  However, 
   // it is necessary for representing templated code
   struct Conditional : Ternary<Category<Category_code::Conditional, Classic>> {
      Arg1_type condition() const { return first(); }
      Arg2_type then_expr() const { return second(); }
      Arg3_type else_expr() const { return third(); }
   };

                                // -- Parameter_list --
   // The sequence of parameter declarations to an abstraction (mapping).  A parameter-list
   // has a declarative region that covers the entirety of the abstraction it is associated with.
   // While a parameter-list node is essentially a container, viewing like an expression allows
   // an operation such as `type()`, yielding a `Product`, that can be useful in constructing the type
   // of the mapping being parameterized.
   struct Parameter_list : Category<Category_code::Parameter_list> {
      virtual const Region& region() const = 0;
      virtual Mapping_level level() const = 0;
      virtual const Sequence<Parameter>& elements() const = 0;
      auto begin() const { return elements().begin(); }
      auto end() const { return elements().end(); }
      auto size() const { return elements().size(); }
   };

                                // -- Directive --
   // Standard C++ has grammar hacks where certain constructs are
   // classified as declarations, by they don't actually declare any name.
   // Rather, the modify the behavior of the implementation in certain ways.
   // For example, a using-declaration does not declare a name: it changes
   // the usual name lookup rules to consider new scopes.  A static-assert
   // does not declare anything: it halts translation when a certain condition
   // does not hold; otherwise a no-op.
   // These constructs are generally known as directives.  They were made
   // declarations in Standard C++, so that they could appear at non-local 
   // scopes -- where general declarations live. 
   struct Directive : Expr {
      virtual Phases phases() const = 0;
   protected:
      constexpr Directive(Category_code c) : Expr{ c } { }
   };

                                // -- Asm --
   // An asm-declaration, a directive in IPR.
   // This directive affects only code generation, where it might inject
   // executable instructions or affect the linker behavior.
   // Its type should be set to "void".
   struct Asm : Category<Category_code::Asm, Directive> {
      virtual const String& text() const = 0;
   };

                                // -- Static_assert --
   // A static assertion: a directive that halts the elaboration phase.
   // No runtime code is ever generated.
   // Its type should be set to "bool". 
   struct Static_assert : Category<Category_code::Static_assert, Directive> {
      virtual const Expr& condition() const = 0;
      virtual Optional<String> message() const = 0;
   };


                                // -- Using_declaration --
   // A using-declaration is directive that instructs the C++ translator to look up
   // a set of names ('designator'), and for each declaration in the qualified lookup 
   // result of a designator create a synonymous declaration, subject to constraints.
   struct Using_declaration : Category<Category_code::Using_declaration, Directive> {
      struct Designator;
      virtual const Sequence<Designator>& designators() const = 0;
   };

   // A using-declarator: a qualified name, along with a denomination mode.
   struct Using_declaration::Designator {
      enum class Mode {
         Normal      = 0x00,              // Normal interpretation of qualified name lookup
         Type        = 0x01,              // The qualified name is assumed to name a type
         Expansion   = 0x02,              // The designator needs expansion
      };

      Designator(const Scope_ref& p, Mode m) : sr{&p}, md{m} { }
      const Scope_ref& path() const { return *sr; }
      Mode mode() const { return md; }
   private:
      const Scope_ref* sr;
      Mode md;
   };

                                // -- Using_directive --
   // A standard C++ using-directive or a using-enum-declaration 
   // (nominating additional scopes) for elaboration purposes.
   // Its type should be "namespace" if it nominates a namespace,
   // or "enum" or "enum class" if it nominates an enumeration.
   struct Using_directive : Category<Category_code::Using_directive, Directive> {
      virtual const Scope& nominated_scope() const = 0;
   };


                                // -- Pragma --
   struct Pragma : Unary<Category<Category_code::Pragma, Directive>, const Sequence<Token>&> {
      const Sequence<Token>& incantation() const { return operand(); }
   };

                                // -- Stmt --
   // The view that a statement is kind of expression does not follow from
   // Standard C++ specification.  It is a design choice we made based on
   // the following facts:
   //    1. We need to have an IPR node that can represent both a
   //       declaration and an expression.  That need is exemplified
   //       by constructs like
   //            if (std::cin >> c) { /* .... */ }
   //       and
   //            if (Call* c = dynamic_cast<Call*>(e)) { /* ... */ }
   //       In the first case we have an expression and in the second
   //       case we have a declaration.  Therefore, we have a diagram
   //       that loooks like
   //
   //              ,----> E.D. <----,
   //              |                |
   //          Expression      Declaration
   //
   //
   //    2. Standard C++ says some declarations are statements, and when
   //       a declaration declares a variable with initialization, the
   //       initializer usually requests code execution.  Therefore, we
   //       chose to say that a declaration is a statement and we get
   //       a similar diagram
   //
   //              ,----> D.S. <----,
   //              |                |
   //         Declaration       Statement
   //
   //    3. In general, IPR is an expression-based language.
   //
   //
   // When combined, the two diagrams yield
   //
   //              ,----> E.D. <---- ----> D.S <----,
   //              |                |               |
   //          Expression      Declaration      Statement
   //
   //
   // Somehow, we have to satisfy that equation.  In a previous design
   // we chose what seemed to be the simplest, i.e. deriving a Statement
   // from an Expr and a Declaration from a Statement.  Doing so
   // however led to numerous questions about some very basic operations on
   // expressions like `arity()' or `type()'.
   //
   // In a second design, we derived a Statement from Node and a
   // Decl from both Expr and Statement.  This led to complications in the
   // class hierarchy and unnecessary complexities.  Therefore, we're back to
   // the view that a statement is an expression, with some simplifications.
   struct Stmt : Expr {
      // The location of this statement in its unit.
      virtual const Unit_location& unit_location() const = 0;
      virtual const Source_location& source_location() const = 0;
      virtual const Sequence<Annotation>& annotation() const = 0;
      virtual const Sequence<Attribute>& attributes() const = 0;

   protected:
      constexpr Stmt(Category_code c) : Expr{ c } { }
   };

                                // -- Expr_stmt --
   // This node class represents an expression statement, e.g.
   //    std::cout << "Hello World" << std::endl;
   // "expr()" is the Expression to evaluate.
   struct Expr_stmt : Unary<Category<Category_code::Expr_stmt, Stmt>> {
      Arg_type expr() const { return operand(); }
   };

                                // -- Labeled_stmt --
   // This node is for labeled-statement:
   //   - identifier : statement
   //   - case constant-expression : statement
   //   - default : statement
   // IPR represents that "label()" as an expressions so that it can
   // handle "identifier", "case cst-expr" and "default", where cst-expr
   // is an arbitrary constant-expression.
   struct Labeled_stmt : Binary<Category<Category_code::Labeled_stmt, Stmt>,
                                const Expr&, const Stmt&> {
      const Expr& label() const { return first(); }
      const Stmt& stmt() const { return second(); }
   };

                                // -- Block --
   // A Block is any sequence of general expressions bracketed by curly braces.
   struct Block : Category<Category_code::Block, Stmt> {
      virtual const Scope& elements() const = 0;
      virtual const Sequence<Expr>& body() const = 0;
      virtual const Sequence<Handler>& handlers() const = 0;
   };

                                // -- Ctor_body --
   // This node represents a constructor "body" consisting of:
   //      (a) member-initializer list, if present; and
   //      (b) the actual body of the constructor
   struct Ctor_body : Binary<Category<Category_code::Ctor_body, Stmt>,
                             const Expr_list&, const Block&> {
      Arg1_type inits() const { return first(); }
      Arg2_type block() const { return second(); }
   };

                                // -- If
   // A classic if-statement.
   struct If : Ternary<Category<Category_code::If, Stmt>,
                       const Expr&, const Stmt&, Optional<Stmt>> {
      Arg1_type condition() const { return first(); }
      Arg2_type consequence() const { return second(); }
      Arg3_type alternative() const { return third(); }
   };

                                // -- Switch --
   // A classic switch-statement.
   struct Switch : Binary<Category<Category_code::Switch, Stmt>,
                          const Expr&, const Stmt&> {
      Arg1_type condition() const { return first(); }
      Arg2_type body() const { return second(); }
   };

                                // -- While --
   // A classic while-statement
   struct While : Binary<Category<Category_code::While, Stmt>,
                         const Expr&, const Stmt&> {
      Arg1_type condition() const { return first(); }
      Arg2_type body() const { return second(); }
   };

                                // -- Do --
   // A classic do-statement
   struct Do : Binary<Category<Category_code::Do, Stmt>, const Expr&, const Stmt&> {
      Arg1_type condition() const { return first(); }
      Arg2_type body() const { return second(); }
   };

                                // -- For --
   // A classic for-statement
   struct For : Category<Category_code::For, Stmt> {
      virtual const Expr& initializer() const = 0;
      virtual const Expr& condition() const = 0;
      virtual const Expr& increment() const = 0;
      virtual const Stmt& body() const = 0;
   };

                                // -- For_in --
   struct For_in : Category<Category_code::For_in, Stmt> {
      virtual const Var& variable() const = 0;
      virtual const Expr& sequence() const = 0;
      virtual const Stmt& body() const = 0;
   };

                                // -- Break --
   // A classic break-statement.
   struct Break : Category<Category_code::Break, Stmt> {
      virtual const Stmt& from() const = 0;
   };

                                // -- Continue --
   // A classic continue-statement.
   struct Continue : Category<Category_code::Continue, Stmt> {
      virtual const Stmt& iteration() const = 0;
   };

                                // -- Goto --
   // A classic goto-statement.
   struct Goto : Unary<Category<Category_code::Goto, Stmt>> {
      Arg_type target() const { return operand(); }
   };

                                // -- Return --
   // A classic return-statement.
   struct Return : Unary<Category<Category_code::Return, Stmt>> {
      Arg_type value() const { return operand(); }
   };

                                // -- Handler --
   // This represents a catch-clause.  Notice that there is no node
   // for "try" as every Block is implicitly a try-block.  Ideally, we
   // should have every expression as a "try-block".
   struct Handler : Binary<Category<Category_code::Handler, Stmt>,
                           const Decl&, const Block&> {
      Arg1_type exception() const { return first(); }
      Arg2_type body() const { return second(); }
   };

                                // -- Substitution --
   // A "Substitution" is a mapping of a parameter to an expression
   // (its value).  It is mainly convenient for representing individual
   // template-argument used to instantiate a template.  Thus, a
   // template-argument list is a sequence of Substitutions.
   struct Substitution {
      Substitution(const Parameter& p, const Expr& x)
            : var(&p), expr(&x) { }

      const Parameter& param() const { return *var; }
      const Expr& value() const { return *expr; }

   private:
      const Parameter* var;
      const Expr* expr;
   };

                                // -- Decl --
   // Only declaration-statements are statements from Standard C++ perspective.
   // However, we find it simpler just to take the general rule that a declaration
   //  is a statement. Furthermore, it should be observed that declarations like
   //   (a) function-definition
   //   (b) template-declaration
   //   (c) explicit-instantiation
   //   (d) explicit-specialization
   //   (e) linkage-specification
   //   (f) namespace-definition
   // are not statement in Standard C++ sense.
   //
   // We take the view that all declarations can be parameterized.
   // Therefore, declaration nodes potentially are instantiations of a
   // a template given by "pattern()", with a set of template-arguments,
   // given by "substitutions()".  A declaration for which we have
   // an empty substitutions() is either
   //     (a) a primary template; or
   //     (b) a non-template declaration.
   struct Decl : Stmt {
      virtual DeclSpecifiers specifiers() const = 0;
      virtual const Linkage& lang_linkage() const = 0;

      virtual const Name& name() const = 0;

      // The region where the declaration really belongs to.
      virtual const Region& home_region() const = 0;

      // The region where this declaration appears -- purely lexical.
      // For many declarations, this is the same as the home region.
      // Exceptions are invisible friends, member functions defined
      // outside of their enclosing class or namespaces.
      virtual const Region& lexical_region() const = 0;

      virtual Optional<Expr> initializer() const = 0;

      // This is the first seen declaration for name() in a given
      // translation unit.  The master declaration is therefore the
      // first element of the declaration-set.
      virtual const Decl& master() const = 0;

      virtual const Sequence<Decl>& decl_set() const = 0;

   protected:
      constexpr Decl(Category_code c) : Stmt{ c } { }
   };

                                // -- Template --
   // This represents a parameterized declaration.  If its
   // template-parameter list is empty, that means that it is
   // either an explicit specialization -- if result() has a
   // non-empty substitutions() -- or a really non-template
   // declaration  -- if result().substitutions() is empty.
   // The list of specializations of this template (either
   // partial or explicit) is given by specializations().
   struct Template : Category<Category_code::Template, Decl> {
      virtual const Template& primary_template() const = 0;
      virtual const Sequence<Decl>& specializations() const = 0;
      virtual const Mapping& mapping() const = 0;

      const Parameter_list& parameters() const { return mapping().parameters(); }
      const Expr& result() const { return mapping().result(); }

      virtual Optional<Template> definition() const = 0;
   };

                                // -- Enumerator --
   // This represents a classic enumerator.
   struct Enumerator : Category<Category_code::Enumerator, Decl> {
      virtual Decl_position position() const = 0;
   };

                                // - Alias --
   // This represent a alias declaration (e.g. typedef, namespace-alias,
   // template alias, ...).
   // An alias is always initialized -- with what it is an alias for.
   // The type of an Alias expression is that of its initializer.
   struct Alias : Category<Category_code::Alias, Decl> {
      const Type& type() const { return initializer().get().type(); }
      const Region& lexical_region() const final { return home_region(); }
   };

                                // -- Base_type --
   // Each base-specifier in a base-clause morally declares an unnamed
   // subobject.  We represent that subobject declaration by a Base_type.
   // For consistency with other non-static members, the name of that
   // subobject is pretended to be the same as that of the base-class
   // so that when it appears in a member-initializer list, it can
   // conveniently be thought of as initialization of that subobject.
   struct Base_type : Category<Category_code::Base_type, Decl> {
      // A base-object is, by definition, unnamed.  However, it
      // is convenient to refer to it by the name of the corresponding
      // type -- in C++ tradition.
      const Name& name() const { return type().name(); }
      virtual Decl_position position() const = 0;
   };

                                // -- Parameter --
   // A parameter is uniquely characterized by its position in
   // a parameter list.
   struct Parameter : Category<Category_code::Parameter, Decl> {
      virtual Decl_position position() const = 0;
      const Region& lexical_region() const final { return home_region(); }
      Optional<Expr> default_value() const { return initializer(); }
   };

                                // -- Fundecl --
   // This node represents a function declaration. Notice that the
   // exception specification is actually made part of the function type.
   struct Fundecl : Category<Category_code::Fundecl, Decl> {
      virtual Optional<Mapping> mapping() const = 0;
      virtual const Parameter_list& parameters() const = 0;
      virtual Optional<Fundecl> definition() const = 0;
   };

                                // -- Var --
   // This represents a variable declaration.  It is also used to
   // represent a static data member.
   struct Var : Category<Category_code::Var, Decl> {
      virtual Optional<Var> definition() const = 0;
   };

                                // -- Field --
   // This node represents a nonstatic data member.
   struct Field : Category<Category_code::Field, Decl> {
      const Region& lexical_region() const final { return home_region(); }
   };

                                // -- Bitfield --
   // A bit-field data member.
   struct Bitfield : Category<Category_code::Bitfield, Decl> {
      virtual const Expr& precision() const = 0;
      const Region& lexical_region() const final { return home_region(); }
   };

                                // -- Typedecl --
   // This node class represents a declaration of a user-defined type.
   struct Typedecl : Category<Category_code::Typedecl, Decl> {
      virtual Optional<Typedecl> definition() const = 0;
   };

                                // -- Translation_unit --
   struct Translation_unit {
      struct Visitor;
      virtual void accept(Visitor&) const = 0;
      virtual const ipr::Global_scope& global_namespace() const = 0;
      virtual const Sequence<Module>& imported_modules() const = 0;
   };

                                // -- Module_unit --
   struct Module_unit : Translation_unit {
      virtual const Module& parent_module() const = 0;
      virtual const Sequence<Decl>& purview() const = 0;
   };

                                // -- Interface_unit --
   struct Interface_unit : Module_unit {
      virtual const Sequence<Module>& exported_modules() const = 0;
      virtual const Sequence<Decl>& exported_declarations() const = 0;
   };

                                // -- Module --
   struct Module {
      virtual const Module_name& name() const = 0;
      virtual const Interface_unit& interface_unit() const = 0;
      virtual const Sequence<Module_unit>& implementation_units() const = 0;
   };

                                // -- Lexicon --
   // This class is intended to capture the set of values for the parameters
   // of the C++ abstract machine.  The most prominent such parameters are
   // the built-int types of the implementation.  It is expected that a given
   // tool can inherit from this class and provide access to the full range of
   // extended types and values that it implements.
   struct Lexicon {
      virtual const Type& void_type() const = 0;               // "void"
      virtual const Type& bool_type() const = 0;               // "bool"
      virtual const Type& char_type() const = 0;               // "char"
      virtual const Type& schar_type() const = 0;              // "signed char"
      virtual const Type& uchar_type() const = 0;              // "unsigned char"
      virtual const Type& wchar_t_type() const = 0;            // "wchar_t"
      virtual const Type& char8_t_type() const = 0;            // "char8_t"
      virtual const Type& char16_t_type() const = 0;           // "char16_t"
      virtual const Type& char32_t_type() const = 0;           // "char32_t"
      virtual const Type& short_type() const = 0;              // "short"
      virtual const Type& ushort_type() const = 0;             // "unsigned char"
      virtual const Type& int_type() const = 0;                // "int"
      virtual const Type& uint_type() const = 0;               // "unsigned int"
      virtual const Type& long_type() const = 0;               // "long"
      virtual const Type& ulong_type() const = 0;              // "unsigned long"
      virtual const Type& long_long_type() const = 0;          // "long long"
      virtual const Type& ulong_long_type() const = 0;         // "unsigned long long"
      virtual const Type& float_type() const = 0;              // "float"
      virtual const Type& double_type() const = 0;             // "double"
      virtual const Type& long_double_type() const = 0;        // "long double"
      virtual const Type& ellipsis_type() const = 0;           // "..."
      virtual const Type& typename_type() const = 0;           // "typename"
      virtual const Type& class_type() const = 0;              // "class" or "struct"
      virtual const Type& union_type() const = 0;              // "union"
      virtual const Type& enum_type() const = 0;               // "enum" or "enum class"
      virtual const Type& namespace_type() const = 0;          // "namespace"

      virtual const Expr& nullptr_value() const = 0;           // "nullptr"      -- technically not a parameter
                                                               // to the C++ abstract machine, but provided as
                                                               // example of symbolic value representation.

      virtual const Linkage& cxx_linkage() const = 0;          // constant for 'extern "C++"'
      virtual const Linkage& c_linkage() const = 0;            // constant for 'extern "C"'
   };
                                // -- Built-in type constants --

   struct Primitive : As_type { };

   struct Global_scope : Namespace { };

   struct Empty_stmt : Expr_stmt { };

                                // -- Visitor --
   struct Visitor {
      virtual void visit(const Node&) = 0;

      virtual void visit(const Annotation&);
      virtual void visit(const Region&);
      virtual void visit(const Comment&);
      virtual void visit(const String&);
      virtual void visit(const Linkage&);

      virtual void visit(const Expr&) = 0;
      virtual void visit(const Classic&);

      virtual void visit(const Name&) = 0;
      virtual void visit(const Identifier&);
      virtual void visit(const Suffix&);
      virtual void visit(const Operator&);
      virtual void visit(const Conversion&);
      virtual void visit(const Template_id&);
      virtual void visit(const Type_id&);
      virtual void visit(const Ctor_name&);
      virtual void visit(const Dtor_name&);
      virtual void visit(const Guide_name&);
      virtual void visit(const Rname&);

      virtual void visit(const Type&) = 0;
      virtual void visit(const Array&);
      virtual void visit(const Class&);
      virtual void visit(const Closure&);
      virtual void visit(const Decltype&);
      virtual void visit(const Enum&);
      virtual void visit(const As_type&);
      virtual void visit(const Tor&);
      virtual void visit(const Function&);
      virtual void visit(const Namespace&);
      virtual void visit(const Pointer&);
      virtual void visit(const Ptr_to_member&);
      virtual void visit(const Product&);
      virtual void visit(const Qualified&);
      virtual void visit(const Reference&);
      virtual void visit(const Rvalue_reference&);
      virtual void visit(const Sum&);
      virtual void visit(const Forall&);
      virtual void visit(const Union&);
      virtual void visit(const Auto&);

      virtual void visit(const Expr_list&);
      virtual void visit(const Overload&);
      virtual void visit(const Scope&);
      virtual void visit(const Phantom&);
      virtual void visit(const Eclipsis&);
      virtual void visit(const This&);
      virtual void visit(const Lambda&);

      virtual void visit(const Symbol&);
      virtual void visit(const Address&);
      virtual void visit(const Array_delete&);
      virtual void visit(const Complement&);
      virtual void visit(const Delete&);
      virtual void visit(const Demotion&);
      virtual void visit(const Deref&);
      virtual void visit(const Enclosure&);
      virtual void visit(const Alignof&);
      virtual void visit(const Sizeof&);
      virtual void visit(const Args_cardinality&);
      virtual void visit(const Expr_stmt&);
      virtual void visit(const Typeid&);
      virtual void visit(const Id_expr&);
      virtual void visit(const Label&);
      virtual void visit(const Not&);
      virtual void visit(const Materialization&);
      virtual void visit(const Post_decrement&);
      virtual void visit(const Post_increment&);
      virtual void visit(const Pre_decrement&);
      virtual void visit(const Pre_increment&);
      virtual void visit(const Promotion&);
      virtual void visit(const Read&);
      virtual void visit(const Throw&);
      virtual void visit(const Unary_minus&);
      virtual void visit(const Unary_plus&);
      virtual void visit(const Expansion&);
      virtual void visit(const Noexcept&);

      virtual void visit(const Rewrite&);
      virtual void visit(const Scope_ref&);
      virtual void visit(const And&);
      virtual void visit(const Array_ref&);
      virtual void visit(const Arrow&);
      virtual void visit(const Arrow_star&);
      virtual void visit(const Assign&);
      virtual void visit(const Bitand&);
      virtual void visit(const Bitand_assign&);
      virtual void visit(const Bitor&);
      virtual void visit(const Bitor_assign&);
      virtual void visit(const Bitxor&);
      virtual void visit(const Bitxor_assign&);
      virtual void visit(const Cast&);
      virtual void visit(const Call&);
      virtual void visit(const Coercion&);
      virtual void visit(const Comma&);
      virtual void visit(const Const_cast&);
      virtual void visit(const Construction&);
      virtual void visit(const Div&);
      virtual void visit(const Div_assign&);
      virtual void visit(const Dot&);
      virtual void visit(const Dot_star&);
      virtual void visit(const Dynamic_cast&);
      virtual void visit(const Equal&);
      virtual void visit(const Greater&);
      virtual void visit(const Greater_equal&);
      virtual void visit(const Less&);
      virtual void visit(const Less_equal&);
      virtual void visit(const Literal&);
      virtual void visit(const Lshift&);
      virtual void visit(const Lshift_assign&);
      virtual void visit(const Member_init&);
      virtual void visit(const Minus&);
      virtual void visit(const Minus_assign&);
      virtual void visit(const Modulo&);
      virtual void visit(const Modulo_assign&);
      virtual void visit(const Mul&);
      virtual void visit(const Mul_assign&);
      virtual void visit(const Narrow&);
      virtual void visit(const Not_equal&);
      virtual void visit(const Or&);
      virtual void visit(const Plus&);
      virtual void visit(const Plus_assign&);
      virtual void visit(const Pretend&);
      virtual void visit(const Qualification&);
      virtual void visit(const Reinterpret_cast&);
      virtual void visit(const Rshift&);
      virtual void visit(const Rshift_assign&);
      virtual void visit(const Static_cast&);
      virtual void visit(const Widen&);
      virtual void visit(const Binary_fold&);
      virtual void visit(const Where&);

      virtual void visit(const Conditional&);
      virtual void visit(const New&);
      virtual void visit(const Mapping&);

      virtual void visit(const Directive&) = 0;
      virtual void visit(const Asm&);
      virtual void visit(const Static_assert&);
      virtual void visit(const Using_declaration&);
      virtual void visit(const Using_directive&);
      virtual void visit(const Pragma&);

      virtual void visit(const Stmt&) = 0;
      virtual void visit(const Labeled_stmt&);
      virtual void visit(const Block&);
      virtual void visit(const Ctor_body&);
      virtual void visit(const If&);
      virtual void visit(const Switch&);
      virtual void visit(const While&);
      virtual void visit(const Do&);
      virtual void visit(const For&);
      virtual void visit(const For_in&);
      virtual void visit(const Break&);
      virtual void visit(const Continue&);
      virtual void visit(const Goto&);
      virtual void visit(const Return&);
      virtual void visit(const Handler&);

      virtual void visit(const Decl&) = 0;
      virtual void visit(const Alias&);
      virtual void visit(const Base_type&);
      virtual void visit(const Bitfield&);
      virtual void visit(const Enumerator&);
      virtual void visit(const Field&);
      virtual void visit(const Fundecl&);
      virtual void visit(const Template&);
      virtual void visit(const Parameter&);
      virtual void visit(const Parameter_list&);
      virtual void visit(const Typedecl&);
      virtual void visit(const Var&);

      virtual void visit(const Global_scope&);
      virtual void visit(const Empty_stmt&);
   };

                                // -- Translation_unit::Visitor --
   struct Translation_unit::Visitor {
      virtual void visit(const Translation_unit&) = 0;
      virtual void visit(const Module_unit&);
      virtual void visit(const Interface_unit&);
   };
}

#endif // IPR_INTERFACE_INCLUDED
