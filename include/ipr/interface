// -*- C++ -*-
//
// This file is part of The Pivot framework.
// Written by Gabriel Dos Reis.
// See LICENSE for copyright and license notices.
//

#ifndef IPR_INTERFACE_INCLUDED
#define IPR_INTERFACE_INCLUDED

#include <cstdint>
#include <utility>
#include <iterator>
#include <stdexcept>
#include <type_traits>
#include <ipr/utility>
#include <ipr/synopsis>
#include <ipr/ancillary>
#include <ipr/location>
#include <ipr/attribute>
#include <ipr/cxx-form>

namespace ipr {
   // IPR is designed to be regular, fully general enough to
   //    (1) represent programs written in full Standard C++
   //        -- except macros -- Standard C, and possibly Fortran
   //        and other C-like languages;
   //    (2) be at the basis of semantics-based program analyses
   //        and transformations;
   //    (3) be ahead of time, i.e. accommodate future possible
   //        extensions to C++, e.g. "concepts";
   //    (4) be compiler-neutral, i.e. not the reflection of internal 
   //        data structures of any particular compiler, no matter how popular.
   //
   // The "meta-language" implemented by IPR is expression-based.  It
   // does not try to mimic the barnacles that the ISO C++ specification
   // has grown over decades -- that way lies unwarranted complexity. Rather,
   // the IPR aims for a regular, general semantics language within which the 
   // various restrictions and irregularities of ISO C++ are accounted for.
   // The focus is on semantics because that is where the essence of C++ lies.
   //
   // IPR nodes "climbing" is based on the Visitor Design Pattern.
   //
   // IPR class nodes come in two flavors:
   //     (a) the interface classes, found in this header;
   //     (b) the implementation classes, found in <ipr/impl>.
   // The primary reason for this separation is, we don't want consumers of
   // the library to critically depend on the particular implementations
   // details of the moment.  Also, it is our intent that the interfaces
   // could be implemented in various ways depending on the particular
   // constraints of the target tools.  Furthermore, a given interface class
   // can admit several implementation classes.
   //
   // A third header file <ipr/traversal> offers a set of traversal
   // facilities.  At the moment, it contains only trivial visitor classes.
   // A fourth header, <ipr/io>, contains interfaces to input/output
   // operations.  At the moment, only output in form of XPR is supported.
   // FIXME: the XPR grammar is out-of-date and is no longer known to capture IPR.
   //
   // The interface classes are non-mutating, i.e. there is no way
   // a client program could modify a node through its interface.
   // In particular, all member functions of the interface classes
   // are const member functions.
   //
   // There is an additional requirement on IPR nodes:  type nodes
   // shall have maximal sharing, i.e. be unified.  The design choices
   // behind that decision are discussed in the paper "Representing
   // C++ Directly, Compactly and Efficiently."
   //
   // Warning:  If you add any new "leaf" node type, you need to update
   //           "ipr/node-category.def" for the numerical mapping.

                                // -- Category_node --
   // A list of numerical codes in one-to-one correspondence with
   // IPR node "interface types".  In a sufficiently expressive and
   // efficient type system, we would not need to manually maintain
   // this list.  This can be seen as an optimization of the traditional
   // double-dispatch process for determining the dynamic type of a node.
   enum class Category_code {
#include <ipr/node-category>
   };

   // -- General structural utility types.

   template<Category_code Cat, class T = Expr>
   struct Category : T {
   protected:
      constexpr Category() : T{ Cat } { }
   };

   // Nesting level of a mapping
   enum class Mapping_level : std::size_t { };

   // Position of a declaration in its declarative region
   enum class Decl_position : std::size_t { };

   // A parameterization is an abstraction over an entity, charted by a collection of parameters.
   template<typename T>
   struct Parameterization {
      virtual const Parameter_list& parameters() const = 0;
      virtual const T& result() const = 0;
   };

   // -- Logogram --
   // A class of words (from a C++ input source) standing for themselves, with no particular elaboration.
   struct Logogram : Basic_unary<const String&> {
      const String& what() const { return operand(); }
      bool operator==(const Logogram& x) const { return &what() == &x.what(); }
      bool operator!=(const Logogram&) const = default;
   };

   // -- Calling_convention --
   // The ISO C++ standards does not explicitly acknowledge function calling conventions, as they
   // are considered low-level implementation details (beyond the fact that a language linkage is a thing).
   // However, in practice, those implementation details bubble up (leaky abstraction) into
   // the system system used by such implementations, in unpleasant ways.  As illustration, just have
   // a look at the chaos introduced by language linkage in function types.
   // Note: language linkage is represented separately; see `Linkage`.
   // An object of this type provides a symbolic representation of a calling convention via an logogram
   // given by the `name()` operation.
   struct Calling_convention {
      explicit constexpr Calling_convention(const Logogram& l) : conv{l} { }
      const Logogram& name() const { return conv; }
      bool operator==(const Calling_convention& x) const { return conv == x.conv; }
      bool operator!=(const Calling_convention&) const = default;
   private:
      const Logogram& conv;
   };

                                // -- Linkage --
   // An object of this type represents language linkage, e.g., "C" in `extern "C"'.
   // The ISO standard mandates at least two language linkages: "C" and
   // "C++".  If those were the only language linkages used in practice,
   // then, we would have just used a 2-valued enum.  However, some C++
   // implementations do have support for things like "Java" language
   // linkage and whatnot.  Consequently, the most general representation
   // is adopted in the form of a logogram.  From ISO C++ point of view, language 
   // linkage applies only to function names, variable names, and function types.  
   // Furthermore, a language linkage applied to a function type is a calling convention.
   struct Linkage {
      explicit constexpr Linkage(const Logogram& l) : lang{l} { }
      const Logogram& language() const { return lang; }
      bool operator==(const Linkage& x) const { return lang == x.lang; }
      bool operator!=(const Linkage&) const = default;
   private:
      const Logogram& lang;
   };

   // -- Transfer --
   // A summary of characteristics of data or control tranfer.  Both language linkage and 
   // calling convention affect how data are transferred to subroutines in function calls.
   // Furthermore, language linkage also affects linking across translation units.
   struct Transfer : Basic_binary<const Linkage&, const Calling_convention&> {
      const Linkage& linkage() const { return first(); }
      const Calling_convention& convention() const { return second(); }
      bool operator==(const Transfer& t) const
      {
         return linkage() == t.linkage() and convention() == t.convention();
      }
      bool operator!=(const Transfer&) const = default;
   };

                                // -- DeclSpecifiers --
   enum class DeclSpecifiers : std::uint32_t {
      None       = 0,
      Register   = 1 << 0,   // Banned from C++17.
      Static     = 1 << 1,
      Extern     = 1 << 2,
      Mutable    = 1 << 3,
      Thread     = 1 << 4,
      StorageClass  = Register | Static | Extern | Mutable | Thread,

      Inline     = 1 << 5,
      Virtual    = 1 << 6,   // also used as storage class specifier
                             // for virtual base subobjects
      Explicit   = 1 << 7,
      Pure       = 1 << 8, 
      FunctionSpecifier = Inline | Virtual | Explicit | Pure,

      Friend     = 1 << 9,
      Typedef    = 1 << 10,

      Public     = 1 << 11,
      Protected  = 1 << 12,
      Private    = 1 << 13,
      AccessProtection = Public | Protected | Private,

      Export     = 1 << 14,  // For exported declarations.
      Constexpr  = 1 << 15,  // C++ 11
      Consteval  = 1 << 16,  // C++20
   };

   constexpr DeclSpecifiers operator|(DeclSpecifiers a, DeclSpecifiers b)
   {
      return DeclSpecifiers(std::uint32_t(a) | std::uint32_t(b));
   }

   constexpr DeclSpecifiers& operator|=(DeclSpecifiers& a, DeclSpecifiers b)
   {
      return a = a | b;
   }

   constexpr DeclSpecifiers operator&(DeclSpecifiers a, DeclSpecifiers b)
   {
      return DeclSpecifiers(std::uint32_t(a) & std::uint32_t(b));
   }

   constexpr DeclSpecifiers& operator&=(DeclSpecifiers& a, DeclSpecifiers b)
   {
      return a = a & b;
   }

   constexpr DeclSpecifiers operator^(DeclSpecifiers a, DeclSpecifiers b)
   {
      return DeclSpecifiers(std::uint32_t(a) ^ std::uint32_t(b));
   }

   constexpr DeclSpecifiers& operator^=(DeclSpecifiers& a, DeclSpecifiers b)
   {
      return a = a ^ b;
   }

   constexpr bool implies(DeclSpecifiers a, DeclSpecifiers b)
   {
      return (a & b) == b;
   }

                                 // -- Lambda_specifiers --
   // Declaration specifiers that can appear on a lambda expression.
   enum class Lambda_specifiers : std::uint32_t {
      None = 0,
      Mutable    = 1 << 0,
      Constexpr  = 1 << 1,
      Consteval  = 1 << 2,
   };

                                // -- Module_name --
   struct Module_name {
      virtual const Sequence<Identifier>& stems() const = 0;
   };

                                // -- Node --
   // Universal base class of all IPR nodes, in the traditional
   // OO design sense.  Its primary purpose is to provide a hook
   // for the Visitor Design Pattern.
   struct Node {
       // the category the complete node object belongs to. In a sufficiently
       // expressive and efficient type system, we would not need this member,
       // for it could be read directly from the type of the object.
      const Category_code category;
      // Hook for visitor classes.
      virtual void accept(Visitor&) const = 0;
   protected:
      // It is an error to create a complete object of this type.
      constexpr Node(Category_code c) : category{ c } { }
      // This class does not have a declared virtual destructor
      // because we don't plan to have Nodes manage resources, and
      // therefore no deletion through pointers to this base class.
      ~Node() = default;
   };

                                // -- String --
   // Strings in IPR are immutable, and therefore unified.
   struct String : Category<Category_code::String, Node> {
      using iterator = util::word_view::const_iterator;
      using Index = std::size_t;
      virtual util::word_view characters() const = 0;
      Index size() const { return characters().size(); }
      iterator begin() const { return characters().begin(); }
      iterator end() const { return characters().end(); }
      static const String& empty_string();            // dedicated node for an empty string
   };

                                // -- Comment --
   // This node represents comments, either C-style or BCPL-style.  Notice
   // that the comment delimiters are part of Comment::text.
   struct Comment : Unary<Category<Category_code::Comment, Node>, const String&> {
      Arg_type text() const { return operand(); }
   };

                                // -- Annotation --
   // A pair "(name, value)" used to communicate information
   // between external tools that use IPR.
   struct Annotation : Binary<Category<Category_code::Annotation, Node>,
                              const String&, const Literal&> {
      Arg1_type name() const { return first(); }
      Arg2_type value() const { return second(); }
   };

                                // -- Region --
   // A Region node represents a region of program text processed into a sequence
   // of expressions or directives.  It is mostly useful for capturing the notion of
   // declarative region, and of scope (in Standard C++ sense).  As such, a genrative
   // entity that can contain declarations has a region: that region is said to be
   // owned by that entity.  On the other hand, not all regions are associated with
   // generative entities.  For example, in
   //      int phi(int (*f)(double x));
   // the declarative region of the parameter scope of the function `phi` is owned by 
   // the Decl for `phi`.  However, the declarative region of the parameter scope of
   // the function parameter (of type 'point to function') is not owned by any entity,
   // not even the type `int (double)` since types are not generative (types are
   // unified in the IPR semantics graph!).
   //
   // In IPR, we're using a generalized notion of Scope (a sequence of
   // declarations).  The  notion of Region helps make precise when
   // some implicit actions like cleanup-ups happen, or nesting of scopes.
   // The sequence of (generalized) expressions appearing in a Region makes up the
   // (compile-time) body of that region.  Evaluating that body usually produces the
   // bindings of that Region.
   struct Region : Category<Category_code::Region, Node> {
      using Location_span = std::pair<Unit_location, Unit_location>;
      virtual const Location_span& span() const = 0;
      virtual const Region& enclosing() const = 0;
      virtual Optional<Expr> owner() const = 0;
      virtual const Sequence<Expr>& body() const = 0;
      virtual const Scope& bindings() const = 0;
      virtual bool global() const = 0;                   // is this region the global region?
   };

                                // -- Expr --
   // An expression is a sequence of operators and operands that specifies
   // a computation.  Such a computation can be static (constant,
   // object, function, type, template, namespace, concept) or dynamic
   // (object, function).  Every expression has a type.
   struct Expr : Node {
      virtual const Type& type() const = 0;

   protected:
      constexpr Expr(Category_code c) : Node{ c } { }
   };

                                // -- Classic --
   // Classic expressions are those constructed with operators
   // directly expressible in standard C++.  Most of those operators
   // can be overloaded and given user-defined implementation. For
   // instance,  cout << 2, involves a user-defined operator.  The IPR
   // representation is not a function call but, something like
   //
   //                        << ---> implementation
   //                       /  \.
   //                    cout   2
   //
   // where we record the fact that the left-shift operator has a
   // user-defined meaning.  In IPR, we take the general approach that
   // all operators can be given user-defined meanings.  Consequently,
   // we define this class to represent the idea that an expression
   // can have a user-supplied meaning.
   //
   // IPR defines a language that is a superset of C++. The term classic
   // refers to the C++ language.
   struct Classic : Expr {
      // For an operation that is given a user-supplied meaning, retrieve
      // the implementation. In non-templated context this returns a
      // user-supplied declaration. In templated contexts it might return
      // an overload set.
      virtual Optional<Expr> implementation() const = 0;

   protected:
      constexpr Classic(Category_code c) : Expr{ c } { }
   };

                                // -- Name --
   // Standard C++ says that 'a name is a use of identifier to designate
   // an entity'.  In IPR we take the view that a name is a symbol
   // (or combination thereof) interpreted in their most abstract sense,
   // i.e. whose meaning depends on binding contexts (Scopes).
   // That definition accounts for the following (in the standard C++ sense)
   //    - unqualified-id                    -- Identifier
   //    - operator-function-id              -- Operator
   //    - conversion-function-id            -- Conversion
   //    - template-id                       -- Template_id
   //    - type-id                           -- Type_id
   //
   // Most names are introduced by declarations into a Region.
   struct Name : Node {
      // At the moment, this class is empty because there is no
      // interesting operation that could be provided here without
      // imposing too much of implementation details.

   protected:
      constexpr Name(Category_code c) : Node{ c } { }
   };

                                // -- Identifier --
   // An identifier is a sequence of alphanumeric characters starting
   // with either a letter or an underbar ('_').
   struct Identifier : Unary<Category<Category_code::Identifier, Name>, const String&> {
      // The character sequence of this identifier
      Arg_type string() const { return operand(); }
   };

                                // -- Suffix --
   // The suffix of a user-defined literal is essential just an identifier
   // with a distinguished interpretation.
   struct Suffix : Unary<Category<Category_code::Suffix, Name>, const Identifier&> {
      Arg_type name() const { return operand(); }
   };

                                // -- Operator --
   // For a function operator "operator @", "opname()" is the "@"
   // sub-part.  Notice that for the array forms of allocation
   // and deallocation operator functions, this is respectively
   // "new[]" and "delete[]", with no space before, between, or after
   // the square brackets.
   struct Operator : Unary<Category<Category_code::Operator, Name>, const String&> {
      Arg_type opname() const { return operand(); }
   };

                                // -- Conversion --
   // A conversion-function-id is the name of a user-defined
   // conversion function.
   struct Conversion : Unary<Category<Category_code::Conversion, Name>, const Type&> {
      // The type this conversion-function converts values to.
      Arg_type target() const { return operand(); }
   };

                                // -- Template_id --
   // A Template_id is a name of the form
   //    template-expr<template-argument-list>
   // which 'applies' a template to a template-argument list.
   struct Template_id : Binary<Category<Category_code::Template_id, Name>,
                               const Expr&, const Expr_list&> {
      Arg1_type template_name() const { return first(); }
      Arg2_type args() const { return second(); }
   };


                                // -- Ctor_name --
   // Standard C++ is not very consistent about constructor
   // name. On one hand, it says constructors do not have names;
   // but on another hand, there are clearly cases where they
   // act as if they had name.  For example, "S::S" designates
   // constructors of class S.  Similarly, if class S has a template
   // constructor then explicit or partial specializations need ways
   // to refer to particular set of specializations.  By consistency
   // with other declarations, and symmetry with destrcutors, we have
   // introduced this node class.
   struct Ctor_name : Unary<Category<Category_code::Ctor_name, Name>, const Type&> {
      Arg_type object_type() const { return operand(); }
   };

                                // -- Dtor_name --
   // This node represent a destructor name of the form "~T", where T
   // is a type.
   struct Dtor_name : Unary<Category<Category_code::Dtor_name, Name>, const Type&> {
      Arg_type object_type() const { return operand(); }
   };
                                // -- Guide_name --
   // This interface class represents the name of a deduction guide.
   // Deduction guides do not have names in Standard C++, and they cannot
   // be found by name lookup.  Yet, they are entities (like templates)
   // that generate compiler-internal instructions (their initializers)
   // that when executed yield deduced template-arguments.  As such, they
   // fit the IPR model of a declaration being an introduction of a name
   // in a scope, with a type and optional initializer.
   struct Guide_name : Unary<Category<Category_code::Guide_name, Name>, const Template&> {
      Arg_type mapping_decl() const { return operand(); }
   };

                                // -- Type_id --
   // This node is used for elaborated expressions that designate types.
   // For example, "const T*" is a Type_id , so is "int (T&)".
   struct Type_id : Unary<Category<Category_code::Type_id, Name>, const Type&> {
      Arg_type type_expr() const { return operand(); }
   };

                                // -- Overload --
   // An overload-set is an expression whose value is the set of all
   // declarations for a name in a given scope.  An overload-set supports
   // look-up by type.  The result of such lookup is the canonical declaration
   // of all declarations with that given type, in that scope.
   struct Overload : Category<Category_code::Overload> {
      virtual Optional<Decl> operator[](const Type&) const = 0;
   };

                                // -- Scope --
   // A "declaration" is a type specification for a name. A "Scope" is
   // a "sequence" of declarations, that additionally supports "lookup"
   // by "Name".  A name may have more than one declarations in a given
   // scope; such a name is said "overloaded".  The result of
   // looking up a name in a scope is a set of all declarations, called
   // an "overload set", for that name in that scope.  An "overload set"
   // is a "sequence" of declarations, that additionally supports
   // lookup by "Type".
   struct Scope : Category<Category_code::Scope> {
      using Iterator = Sequence<Decl>::Iterator;

      // The sequence of declarations this scope contain.
      virtual const Sequence<Decl>& elements() const = 0;

      // Look-up by name returns the overload-set of all declarations,
      // for the subscripting name, contained in this scope.
      virtual Optional<Overload> operator[](const Name&) const = 0;

      // How may declarations are there in this Scope.
      auto size() const { return elements().size(); }

      Iterator begin() const { return elements().begin(); }
      Iterator end() const { return elements().end(); }
   };

                                // -- General types --
   // A type is a collection of constraints and operations that preserve
   // some invariants.  Since a Type is also an Expression, it has a type.
   // A type of a type is an instance of a concept - a constraint.  A type 
   // in IPR has a much broader significance than Standard C++ types 
   // (henceforth called "classic type").  In particular, in IPR, "namespace"
   // is a type. Similarly, an overload-set has a type.
   // Some C++ implementations define "extended built-in" types with
   // language linkage, e.g. `extern "Java"' or `extern "Fortran"', for
   // interoperating with other languages.  The current representation
   // includes language linkage as integral part of Type.
   // Almost all types have "C++" language linkage.  The exceptions are: 
   //   a. As_type built with explicit language specification or more generally
   //      data or control transfer
   //   b. Function built with explicit language specification or more generally
   //      data or control transfer
   struct Type : Expr {
      virtual const Name& name() const = 0;
      virtual const Transfer& transfer() const = 0;
      const Linkage& linkage() const { return transfer().linkage(); }
   protected:
      constexpr Type(Category_code c) : Expr{ c } { }
   };

                                // -- Array --
   // An array-type describes object expressions that designate C-style
   // homogenous object containers that meet the random-access
   // requirements.  When an array-type is declared with unspecified
   // bound, "bound()" returns a null-expression.
   // An alternate design choice would have been to have a predicate
   // "has_unknown_bound()", which when true would make "bound()" throw
   // an exception if accessed.
   struct Array : Binary<Category<Category_code::Array, Type>, const Type&> {
      Arg1_type element_type() const { return first(); }
      Arg2_type bound() const        { return second(); }
   };

                                // -- As_type --
   // This node represents the use of a general expression as
   // a type.  Such situation arises in cases where a declaration
   // node can be used to designate a type, as in:
   //    struct S;
   //    typedef int count;
   //    typename T::size_type s = 90;
   //    template<typename T, T t> ...
   struct As_type : Unary<Category<Category_code::As_type, Type>> {
      Arg_type expr() const { return operand(); }
   };

                                // -- Decltype --
   // This node represents query for the "generalized declared type"
   // of an expression.
   struct Decltype : Unary<Category<Category_code::Decltype, Type>, const Expr&> {
      Arg_type expr() const { return operand(); }
   };

                                // -- Tor --
   // A node of this class represents a Type for either a constructor or a destructor.
   // Formally, ISO C++ does not assign types to those special functions; however, a
   // type-based representation of C++ semantics must assign types to such declarations.
   // Although a low-level (e.g. ABI-level) representation of a contructor and a destructor
   // may look at them as just some regular function, and assign them a Function type,
   // the higher level semantics of C++ is best served by a dedicated type to abstract
   // over ABI interpretation.
   struct Tor : Binary<Category<Category_code::Tor, Type>, const Expr&, const Type&> {
      // The parameter-list to a tor type.  Always empty for a Standard C++ destructor.
      Arg1_type source() const { return first(); }
      // The exception-specification for this tor type.
      Arg2_type throws() const { return second(); }
   };

                                // -- Function --
   // This node class represents a Type that describes an expression
   // that refers to a function.  In full generality, a template
   // is a also a function (it describes Type-valued functions);
   // however, we've made a special node for template.  ISO C++ specifies
   // that function types have language linkages and two function types
   // with different language linkages are different.
   // Furthermore, low-level implementation details such as calling conventions
   // are accounted for through `Type::transfer()`.
   struct Function : Ternary<Category<Category_code::Function, Type>,
                              const Product&, const Type&, const Expr&> {
      // Parameter-type-list of a function of this type.  In full
      // generality, this also describes template signature.
      Arg1_type source() const { return first(); }

      // return-type
      Arg2_type target() const { return second(); }

      // Either a boolean expression indicating when values of this type can throw,
      // or a list of exception types a function of this type may throw.
      Arg3_type throws() const { return third(); }
   };

                                // -- Pointer --
   // A pointer-type is type that describes an Address node.
   struct Pointer : Unary<Category<Category_code::Pointer, Type>, const Type&> {
      // The type of the entity whose address an object of this
      // type may hold.
      Arg_type points_to() const { return operand(); }
   };

                                // -- Product --
   // A Product represents a Cartesian product of Types.  Pragmatically,
   // it may be viewed as a Sequence of Types.  It is a Type.
   struct Product : Unary<Category<Category_code::Product, Type>, const Sequence<Type>&> {
      using Index = std::size_t;
      Arg_type elements() const { return operand(); }
      auto size() const { return elements().size(); }
      const Type& operator[](Index i) const { return *elements().position(i); }
   };

                                // -- Ptr_to_member --
   // This is for pointer-to-member type, e.g. int A::* or void (A::*)().
   // A pointer to member really is not a pointer type, it is much closer
   // a pair of a type and offset that usual pointer types.
   struct Ptr_to_member : Binary<Category<Category_code::Ptr_to_member, Type>,
                                 const Type&, const Type&> {
      Arg1_type containing_type() const { return first(); }
      Arg2_type member_type() const { return second(); }
   };

                                // -- Qualified --
   // A cv-qualified type.  Representing a cv-qualified type with all
   // available information attainable in at most one indirection is
   // very tricky. Consequently, we currently represents a cv-qualified
   // type with a separate node as a binary operator.  Notice that we
   // maintain the invariant
   //     Qualified(cv2, Qualified(cv1, T)) = Qualified(cv1 | cv2, T)
   // In particular, the Qualified::main_variant is never a Qualified node.
   // We also maintain the invariant that Qualified::qualifiers is never
   // Type::None, consequently it is an error to attempt to create such a node.
   struct Qualified : Binary<Category<Category_code::Qualified, Type>,
                             ipr::Type_qualifiers, const Type&> {
      Arg1_type qualifiers() const { return first(); }
      Arg2_type main_variant() const { return second(); }
   };

                                // -- Reference --
   // A reference-type describes an expression that acts like an alias
   // for a object or function.  However, unlike a pointer-type, it is
   // not an object-type.
    struct Reference : Unary<Category<Category_code::Reference, Type>, const Type&> {
       // The type of the object or function an expression of this
       // type refers to.
       Arg_type refers_to() const { return operand(); }
    };

                                // -- Rvalue_reference --
   // An rvalue-reference-type to support move semantics.
    struct Rvalue_reference : Unary<Category<Category_code::Rvalue_reference, Type>,
                                    const Type&> {
       // The type of the object or function an expression of this
       // type refers to.
       Arg_type refers_to() const { return operand(); }
    };

                                // -- Sum --
   // A Sum type represents a distinct union of types.  This is currently
   // used only for dynamic exception specification in Function type.
   struct Sum : Unary<Category<Category_code::Sum, Type>, const Sequence<Type>&> {
      using Index = std::size_t;
      Arg_type elements() const { return operand(); }
      auto size() const { return elements().size(); }
      const Type& operator[](Index i) const { return *elements().position(i); }
   };

                                // -- Forall --
   // This represents a universally quantified type, parameterized by any compile-time sort;
   // that is, all values for the parameters must designate compile-time entities.
   // It is useful for representing the type of a template declaration, and more.  In the near future,
   // when "concepts" are integrated, it will become a Ternary node where the
   // third operand will represent the "where-clause".
   struct Forall : Binary<Category<Category_code::Forall, Type>,
                            const Product&, const Type&> {
      // The constraints or types of the template-parameters.
      const Product& source() const { return first(); }
      // The type of the instantiation result.
      const Type& target() const { return second(); }
   };

                                // -- Udt --
   // Base class for user-defined types Nodes -- factor out common properties.
   template<typename T>
   struct Udt : Type {
      // The general interface to members of this user-defined type.
      using Member = T;
      // The region delimited by the definition of this Udt.
      virtual const Region& region() const = 0;
      const Scope& scope() const { return region().bindings(); }
      virtual const Sequence<Member>& members() const = 0;

   protected:
      // It is an error to create a node of this type.
      constexpr Udt(Category_code c) : Type{ c } { }
   };

                                // -- Namespace --
   // A Standard C++ namespace is a compile-time accumulative singleton variable
   // that is initialized with a sequence of declarations.  The type of 
   // such a variable is given by an IPR "namespace" type.
   struct Namespace : Category<Category_code::Namespace, Udt<Decl>> {
      const Sequence<Decl>& members() const final { return scope().elements(); }
   };

                                // -- Class --
   struct Class : Category<Category_code::Class, Udt<Decl>> {
      const Sequence<Decl>& members() const final { return scope().elements(); }
      virtual const Sequence<Base_type>& bases() const = 0;
   };

                                // -- Union --
   struct Union : Category<Category_code::Union, Udt<Decl>> {
      const Sequence<Decl>& members() const final { return scope().elements(); }
   };

                                // -- Enum --
   // An enumeration is an object-type whose members are named constants
   // the definitions of which as part of the definition of the enumeration
   // itself.  By historical accident, enumerators are not "properly scoped".
   // The underlying type of the enumeration is given by `base()`, when explicitly
   // specified or inferred from the enumerator list.
   struct Enum : Category<Category_code::Enum, Udt<Enumerator>> {
      enum class Kind : std::uint8_t {     // The kind of enum.
         Legacy,                      // traditional C-style enum
         Scoped                       // scoped enum (C++11)
      };
      virtual Kind kind() const = 0;
      virtual Optional<Type> base() const = 0;
   };

                                // -- Auto --
   struct Auto : Category<Category_code::Auto, Type> {
   };


   // A capture is a description of how a local entity is referenced in a lambda expression.
   // It is essentially a pair (Binding_mode, Decl) where the first component tells how the 
   // entity is referenced (by value or by reference), and a declaration that specifies the 
   // declarative semantic properties of the captured entity.
   // Note: A Capture should not be confused with a Capture_specification: the specification
   //       is a prescription of how an entity should be captured (either explicitly or implicitly) 
   //       in a lambda, whereas a capture is a result of executing that prescription.
   struct Capture {
      virtual Binding_mode mode() const = 0;
      virtual const Decl& entity() const = 0;
   };

                                // -- Closure --
   // A closure type is the type of a lambda expression, which ISO C++ confusingly requires
   // to be a non-union class type.  The logical representation in the IPR has it as a distinct
   // (generative) user-defined type whose members are captures.   Each lambda expression has
   // its own unique type, even if its members would be otherwise the same.
   struct Closure : Category<Category_code::Closure, Udt<Capture>> { };

                                // -- Phantom --
   // This nodes represents a missing expression, as in the "bound" of an array type with
   // unknown bound, e.g. in "unsigned char charset[];", or in an empty expression-statement.
   // We do not unify Phantom expressions, as two arrays with
   // unknown bounds may not designate the same type.
   struct Phantom : Category<Category_code::Phantom> { };


                                // -- Eclipsis --
   // Representation of the `...' in a unary fold, e.g. `... + e'.
   // Note: that `...' is not the pack expansion operator.  There is no operand to the `...' here.
   // While the syntax looks the same, the meaning is really different.  It stands for something
   // was omitted, hence the name.
   struct Eclipsis : Category<Category_code::Eclipsis> { };

   // Semantic description of the variety of lambda capture specifications:
   //   - default captures: indicated by the squiggles "=" (by value), and "&" (by reference) at source level
   //   - implicit object: indicated by "this" (by reference), and "*this" (by value) at source level
   //   - named symbols: local enclosing variable, and locally introduced variable (with initializer) at source level
   struct Capture_specification {
      struct Default;                           // default lambda capture specification
      struct Implicit_object;                   // capture mode of implicit object
      struct Named;                             // named simple capture; base of Simple and With_initializer
      struct Enclosing_local;                   // simply named captured local entity
      struct Binding;                           // capture with initialization
      struct Expansion;                         // expansion of a lambda capture

      struct Visitor;
      virtual void accept(Visitor&) const = 0;
   };

                                // -- Lambda --
   struct Lambda : Category<Category_code::Lambda>, Parameterization<Expr> {
      virtual const Closure& type() const override = 0;           // a lambda is of a (unique) closure type
      virtual Optional<Type> target() const = 0;                  // return type, optionally specified at source level
      virtual Optional<Expr> requirement() const = 0;             // declaration constraint possibly involving parameters
      virtual const Sequence<Attribute>& attributes() const = 0;  // optional attribute-list applying to the lambda
      virtual Optional<Expr> eh_specification() const = 0;
      virtual Lambda_specifiers specifiers() const = 0;
      virtual const Sequence<Capture_specification>& captures() const = 0;
   };

   // Default lambda capture specification
   struct Capture_specification::Default : Capture_specification {
      virtual Binding_mode mode() const = 0;
   };

   // Lambda capture specification of the implicit object in a non-static member context.
   // The designation of the capture is defined by how(), where:
   //   - Binding_mode::Reference means 'this'
   //   - Binding_mode::Copy means '*this'
   //   - anything else is invalid at this point.
   // Note: an alternative design is to introduced a distinct enum for representing the
   //       designation of the implicit object (say 'This' and 'Self), but that would
   //       have just obscured the fundamental semantics correspondence.
   struct Capture_specification::Implicit_object : Capture_specification {
      virtual Binding_mode how() const = 0;
   };

   // Base of lambda captures designated by an given name.
   struct Capture_specification::Named : Capture_specification {
      virtual const Identifier& name() const = 0;
      virtual Binding_mode mode() const = 0;
   };

   // Lambda capture referencing a local entity from the enclosing context.
   struct Capture_specification::Enclosing_local : Capture_specification::Named {
      virtual const Decl& declaration() const = 0;
   };

   // Lambda capture introducing an alias bound to the result of evaluating
   // an expression in the (local) context of the lambda body.
   struct Capture_specification::Binding : Capture_specification::Named {
      virtual const Expr& initializer() const = 0;
   };

   // Lambda capture expansion of either an enclosing variable pack, or a local binding pack.
   struct Capture_specification::Expansion : Capture_specification {
      virtual const Named& what() const = 0;
   };

   struct Capture_specification::Visitor {
      virtual void visit(const Default&) = 0;
      virtual void visit(const Implicit_object&) = 0;
      virtual void visit(const Enclosing_local&) = 0;
      virtual void visit(const Binding&) = 0;
      virtual void visit(const Expansion&) = 0;
   };

                                // -- Symbol --
   // Representation of self-evaluating (generalized) expressions, i.e. irreducible expressions.
   // That includes builtin types, as well as designated special values such as `nullptr'.
   // Note: A symbol is uniquely identified by the pair (name, type), so a symbol can be `overloaded'.
   // Symbol nodes are unified, as they are self-evaluating, e.g. core values.
   struct Symbol : Unary<Category<Category_code::Symbol>, const Name&> {
      const Name& name() const { return operand(); }
   };

                                // -- Address --
   // Address-of expression -- "&expr"
   struct Address : Unary<Category<Category_code::Address, Classic>> { };

                                // -- Array_delete --
   // Array-form of delete-expression --  "delete[] p"
   struct Array_delete : Unary<Category<Category_code::Array_delete, Classic>> {
      const Expr& storage() const { return operand(); }
   };

                                // -- Asm --
   // An ISO C++ asm-declaration, an expression in IPR.
   // When evaluated, this expression produces executable instructions or 
   // affects linking behavior. Its type is `void`.
   // Note: A node of this type is typically an operand of `Phased_evaluation`.
   struct Asm : Unary<Category<Category_code::Asm>, const String&> {
      const String& text() const { return operand(); }
   };

                                // -- Complement --
   // Complement-expression -- "~expr"
   struct Complement : Unary<Category<Category_code::Complement, Classic>> { };

                                // -- Delete --
   // Delete-expression -- "delete p"
   struct Delete : Unary<Category<Category_code::Delete, Classic>> {
      const Expr& storage() const { return operand(); }
   };

                                // -- Demotion --
   // Integral or floating point conversion
   struct Demotion : Unary<Category<Category_code::Demotion>> { };

                                // -- Deref --
   // Dereference-expression -- "*expr"
   struct Deref : Unary<Category<Category_code::Deref, Classic>> { };

                                // -- Enclosure --
   // Expresion enclosed in matching pair of delimiters.  This might seem purely
   // syntactical but it also has semantic implications, like when an
   // argument-dependent lookup should be done or not, or order of evaluation,the accuracy
   // of an expression evaluation.
   // Note: an empty brace-init translates to a brace enclosure of a Phantom node.
   struct Enclosure : Unary<Category<Category_code::Enclosure>> {
      virtual Delimiter delimiters() const = 0;
      const Expr& expr() const { return operand(); }
   };

                                // -- Expr_list --
   // A sequence of expressions "e1, e2, ..., eN".  This form of expression
   // is a tuple of expressions.  In particular, an Expr_list is different
   // from a Comma expression -- where each sub-expression is evaluated,
   // discarded except the last one.  The type of an Expr_list
   // is a Product.
   struct Expr_list : Unary<Category<Category_code::Expr_list>, const Sequence<Expr>&> {
      using Index = std::size_t;
      Arg_type elements() const { return operand(); }
      auto size() const { return elements().size(); }
   };

                                // -- Alignof --
   //  Alignment query of a type, or any expression.
   struct Alignof : Unary<Category<Category_code::Alignof>> { };

                                // -- Sizeof --
   // sizeof-expression -- "sizeof expr" or "sizeof (int)"
   struct Sizeof : Unary<Category<Category_code::Sizeof>> { };

                                // -- Args_cardinality --
   struct Args_cardinality : Unary<Category<Category_code::Args_cardinality>> { };

                                // -- Restriction --
   // Representation of what ISO C++ calls "requires-clause", an expression of the form
   //      `requires` constant-expression
   // at the input source level.  Not to be confusion with "requires-expression".
   struct Restriction : Unary<Category<Category_code::Restriction>> { };

                                // -- Noexcept --
   struct Noexcept : Unary<Category<Category_code::Noexcept>> { };

                                // -- Typeid --
   // typeid-expression -- "typeid (expr)", or "typeid (int)"
   struct Typeid : Unary<Category<Category_code::Typeid>> { };

                                // -- Id_expr --
   // This node represents use of a name to designate an entity.
   // In general, names are introduced by a declaration.  In a well-formed
   // fully elaborated program, a use of name refers to exactly one declaration.
   // However, in a partially elaborated program (e.g. a template definition)
   // a dependent name may refer to zero, one, or many (overloaded) declarations.
   struct Id_expr : Unary<Category<Category_code::Id_expr, Expr>, const Name&> {
      // The set of declarations the name refers to, at the elaboration point.
      virtual Optional<Expr> resolution() const = 0;

      Arg_type name() const { return operand(); }
   };

                                // -- Label --
   // label-expression.  Appears in goto-statements.
   struct Label : Unary<Category<Category_code::Label>, const Identifier&> {
      Arg_type name() const { return operand(); }
   };

                                // -- Materialization --
   // Temporary materialization
   struct Materialization : Unary<Category<Category_code::Materialization>> { };

                                // -- Not --
   // logical-not-expression -- "!expr"
   struct Not : Unary<Category<Category_code::Not, Classic>> { };

                                // -- Post_decrement --
   // post-decrement-expression -- "expr--".
   struct Post_decrement : Unary<Category<Category_code::Post_decrement, Classic>> { };

                                // -- Post_increment --
   // post-increment-expression -- "expr++".
   struct Post_increment : Unary<Category<Category_code::Post_increment, Classic>> { };

                                // -- Pre_decrement --
   // pre-decrement-expression -- "--expr".
   struct Pre_decrement : Unary<Category<Category_code::Pre_decrement, Classic>> { };

                                // -- Pre_increment --
   // pre-increment-expression -- "++expr".
   struct Pre_increment : Unary<Category<Category_code::Pre_increment, Classic>> { };

                                // -- Promotion --
   // Integral or floating point promotion -- "(int)'2'"
   struct Promotion : Unary<Category<Category_code::Promotion>> { };

                                // -- Construction --
   // An expression of the form "T(e1, e2, .. en)" or "T{e1, e2, .. en}"
   // where "T" is a type and "ei"s are expressions.  This is not a function
   // call -- although syntactically it looks like so.  "T" will
   // be the `type()' of this expression.
   // The contructor selected for the construction operation is indicated
   // by implementation, which is inherited from Classic. When the enclosure
   // is a singleton, the node can also denote a functional cast expression.
   struct Construction : Unary<Category<Category_code::Construction, Classic>,
                               const Enclosure&> {
      // The sequence of arguments used for this construction
      Arg_type arguments() const { return operand(); }
   };

                                // -- Read --
   // Lvalue-to-rvalue conversion -- "= var"
   struct Read : Unary<Category<Category_code::Read>> { };

                                // -- Throw --
   // A node that represents a C++ expression of the form `throw ex'.
   // As a special case, when exception() is a null-expression, then
   // this node represents the flow-control "throw;", which actually
   // could be represented by a dedicated statement node, Rethrow for
   // instance.
   struct Throw : Unary<Category<Category_code::Throw, Classic>> {
      const Expr& exception() const { return operand(); }
   };

                                // -- Unary_minus --
   // unary-minus-expression -- "-expr"
   struct Unary_minus : Unary<Category<Category_code::Unary_minus, Classic>> { };

                                // -- Unary_plus --
   // unary-plus-expression -- "+expr"
   struct Unary_plus : Unary<Category<Category_code::Unary_plus, Classic>> { };

                                // -- Expansion --
   // Pack expansion.  The operand can be both a classic expression
   // or a type.  Standard C++ does not permit overloading of expansion
   // operator, but the general IPR model here allows it.
   struct Expansion : Unary<Category<Category_code::Expansion, Classic>> { };

                                // -- Rewrite --
   // Various ISO C++ syntactic constructs are defined - unwwisely -
   // via translation to more elaborate sequences of tokens or parse trees.
   // The `source()` is the construct as written in the input source code, and the
   // `target()` is the internal expression giving meaning to the source.
   struct Rewrite : Binary<Category<Category_code::Rewrite>> {
      const Expr& source() const { return first(); }
      const Expr& target() const { return second(); }
      const Type& type() const final { return second().type(); }
   };

                                // -- Member_selection<> --
   // This class factorizes the commonalities of various object member
   // selection operation.
   template<Category_code Cat>
   struct Member_selection : Binary<Category<Cat, Classic>> {
      const Expr& base() const { return this->first(); }
      const Expr& member() const { return this->second(); }
   };

                                // -- Cast_expr<> --
   // This classes factorizes the commonalities of various cast-expressions
   template<Category_code Cat>
   struct Cast_expr : Binary<Category<Cat, Classic>, const Type&> {
      // The type() of a cast expression is its first() operand.  However,
      // we do not define (override) that member here, as it implies two
      // indirections to get the information.  Therefore, it is better
      // to define it at the implementation side where we have all the bits
      // necessary to make it a single indirection.

      const Expr& expr() const { return this->second(); }
   };

                                // -- Scope_ref --
   // A qualified name of the form "scope::member".
   // Although the scope resolution operator ('::') in this expression
   // cannot be overloaded in standard C++ (yet), it is conceptually
   // dual to the dot operator, for which overloading has been
   // suggested multiple time with an operational model.  Consequently,
   // a qualified name is modelled as a classic expression.
   struct Scope_ref : Binary<Category<Category_code::Scope_ref, Classic>> {
      Arg1_type scope() const  { return first(); }
      Arg2_type member() const { return second(); }
   };

                                // -- Plus --
   // Addition-expression -- "a + b"
   struct Plus : Binary<Category<Category_code::Plus, Classic>> { };

                                // -- Plus_assign --
   // In-place addition-expression -- "a += b"
   struct Plus_assign : Binary<Category<Category_code::Plus_assign, Classic>> { };

                                // -- And --
   // Logical-and-expression -- "a && b"
   struct And : Binary<Category<Category_code::And, Classic>> { };

                                // -- Array_ref --
   // This is for an expression that designate a particular slot
   // in an array expression `array[slot]'.
   struct Array_ref : Member_selection<Category_code::Array_ref> { };

                                // -- Arrow --
   // This node type models object member selection, based on pointer,
   // using the arrow-notation.  See `Dot'.
   struct Arrow : Member_selection<Category_code::Arrow> { };

                                // -- Arrow_star --
   // Member selection through pointer to member -- "p->*"
   struct Arrow_star : Member_selection<Category_code::Arrow_star> { };

                                // -- Assign --
   // Assignment-expression -- "a = b"
   struct Assign : Binary<Category<Category_code::Assign, Classic>> { };

                                // -- Bitand --
   // Bit-and-expression -- "a & b"
   struct Bitand : Binary<Category<Category_code::Bitand, Classic>> { };

                                // -- Bitand_assign --
   // In-place bit-and-expression -- "a &= b"
   struct Bitand_assign : Binary<Category<Category_code::Bitand_assign, Classic>> { };

                                // -- Bitor --
   // Bit-or expression -- "a | b"
   struct Bitor : Binary<Category<Category_code::Bitor, Classic>> { };

                                // -- Bitor_assign --
   // In-place bit-or-expression -- "a |= b"
   struct Bitor_assign : Binary<Category<Category_code::Bitor_assign, Classic>> { };

                                // -- Bitxor --
   // Exclusive bit-or-expression -- "a ^ b"
   struct Bitxor : Binary<Category<Category_code::Bitxor, Classic>> { };

                                //  -- Bitxor_assign --
   // In-place exclusive bit-or-expression -- "a ^= b"
   struct Bitxor_assign : Binary<Category<Category_code::Bitxor_assign, Classic>> { };

                                //  -- Cast --
   // An expression of the form "(type) expr", representing the
   // old-style/C-style cast.
   struct Cast : Cast_expr<Category_code::Cast> { };

                                // -- Call --
   // A function call with an argument list.  Notice that in the abstract
   // this is not really different from an Template_id.  However, having
   // a separate node means less clutter in codes.
   struct Call : Binary<Category<Category_code::Call, Classic>,
                         const Expr&, const Expr_list&> {
      Arg1_type function() const  { return first(); }
      Arg2_type args() const { return second(); }
   };

                                // -- Coercion --
   // A generalized type conversion either built-in to the language or
   // programmatically defined by either constructors or conversion
   // functions.
   struct Coercion : Binary<Category<Category_code::Coercion, Classic>, const Expr&, const Type&> {
      Arg1_type expr() const { return first(); }
      Arg2_type target() const { return second(); }
   };

                                // -- Comma --
   // comma-expression -- "a, b"
   struct Comma : Binary<Category<Category_code::Comma, Classic>> { };

                                // -- Const_cast --
   // const_cast-expression -- "const_cast<type>(expr)".
   struct Const_cast : Cast_expr<Category_code::Const_cast> { };

                                // -- Div --
   // Division-expression -- "a / b"
   struct Div : Binary<Category<Category_code::Div, Classic>> { };

                                //  -- Div_assign --
   // In-place division-expression -- "a /= b"
   struct Div_assign : Binary<Category<Category_code::Div_assign, Classic>> { };

                                // -- Dot --
   // This node type represents a member selection on object using
   // the dot-notation "object.member": both "object" and "member"
   // can be general expressions.
   struct Dot : Member_selection<Category_code::Dot> { };

                                // -- Dot_star --
   // An expression of the form "object.*pm".
   struct Dot_star : Member_selection<Category_code::Dot_star> { };

                                // -- Dynamic_cast --
   // An expression of the from "dynamic_cast<type>(expr)".
   struct Dynamic_cast : Cast_expr<Category_code::Dynamic_cast> { };

                                // -- Equal --
   // Equality-comparison-expression -- "a == b"
   struct Equal : Binary<Category<Category_code::Equal, Classic>> { };

                                // -- Greater --
   // greater-comparison-expression -- "a > b"
   struct Greater : Binary<Category<Category_code::Greater, Classic>> { };

                                // -- Greater_equal --
   // greater-or-equal-comparison-expression -- "a >= b"
   struct Greater_equal : Binary<Category<Category_code::Greater_equal, Classic>> { };

                                // -- Less --
   // less-comparison-expression -- "a < b"
   struct Less : Binary<Category<Category_code::Less, Classic>> { };

                                // -- Less_equal --
   // less-equal-comparison-expression -- "a <= b"
   struct Less_equal : Binary<Category<Category_code::Less_equal, Classic>> { };

                                // -- Literal --
   // An IPR literal is just like a standard C++ literal.
   struct Literal : Binary<Category<Category_code::Literal, Classic>,
                           const Type&, const String&> {
      // See comments for the cast operators regarding type().

      // The textual representation of this literal as it appears
      // in the program text.
      Arg2_type string() const { return second(); }
   };

                                // -- Binary_fold --
   // Representation of a binary fold expression, e.g. `(x + ... + y)'.
   // The first() operand designates `x', and the second() operand designates `y'.
   // The operation() is the category code for the operation being folded.
   struct Binary_fold : Binary<Category<Category_code::Binary_fold, Classic>> {
      virtual Category_code operation() const = 0;
   };

                                // -- Mapping --
   // This node represents a parameterized expression.
   // Its type is a Function in case of parameterized classic expression,
   // and Forall otherwise.
   struct Mapping : Category<Category_code::Mapping>, Parameterization<Expr> {
   };

                                // -- Member_init --
   // Node that represent a member initialization, in constructor
   // definition.
   struct Member_init : Binary<Category<Category_code::Member_init>> {
      Arg1_type member() const { return first(); }
      Arg2_type initializer() const { return second(); }
   };

                                // -- Minus --
   // Subtraction-expression -- "a - b"
   struct Minus : Binary<Category<Category_code::Minus, Classic>> { };

                                //  -- Minus_assign --
   // In-place subtraction-expression -- "a -= b".
   struct Minus_assign : Binary<Category<Category_code::Minus_assign, Classic>> { };

                                // -- Modulo --
   // Modulo-expression -- "a % b"
   struct Modulo : Binary<Category<Category_code::Modulo, Classic>> { };

                                // -- Modulo_assign --
   // In-place modulo-expression -- "a %= b"
   struct Modulo_assign : Binary<Category<Category_code::Modulo_assign, Classic>> { };

                                // -- Mul --
   // Multiplication-expression -- "a * b"
   struct Mul : Binary<Category<Category_code::Mul, Classic>> { };

                                // -- Mul_assign --
   // In-place multiplication-expression -- "a *= b"
   struct Mul_assign : Binary<Category<Category_code::Mul_assign, Classic>> { };

                                   // -- Narrow --
   // Checked base to derived class conversion. This is always a non-implicit
   // conversion and exists to add additional semantic context to otherwise
   // explicit conversion nodes.
   struct Narrow : Binary<Category<Category_code::Narrow>, const Expr&, const Type&> {

      Arg1_type expr() const { return first(); }
      Arg2_type derived() const { return second(); }
   };

                                // -- Not_equal --
   // Inequality-comparison-expression -- "a != b"
   struct Not_equal : Binary<Category<Category_code::Not_equal, Classic>> { };

                                // -- Or --
   // logical-or-expression -- "a || b"
   struct Or : Binary<Category<Category_code::Or, Classic>> { };

                                // -- Pretend --
   // Generalization of bitcast and reinterpret cast
   struct Pretend : Binary<Category<Category_code::Pretend>, const Expr&, const Type&> {
      Arg1_type expr() const { return first(); }
      Arg2_type target() const { return second(); }
   };

                                // -- Qualification --
   // A conversion that add cv-qualifiers
   struct Qualification : Binary<Category<Category_code::Qualification>, const Expr&, Type_qualifiers> {
      Arg1_type expr() const { return first(); }
      Arg2_type qualifiers() const { return second(); }
   };

                                // -- Reinterpret_cast --
   // An expression of the form "reinterpret_cast<type>(expr)"
   struct Reinterpret_cast : Cast_expr<Category_code::Reinterpret_cast> { };

                                // -- Lshift --
   // left-shift-expression -- "a << b"
   struct Lshift : Binary<Category<Category_code::Lshift, Classic>> { };

                                // -- Lshift_assign --
   // In-place left-shift-expression -- "a <<= b".
   struct Lshift_assign : Binary<Category<Category_code::Lshift_assign, Classic>> { };

                                // -- Rshift --
   // Right-shift-expression -- "a >> b"
   struct Rshift : Binary<Category<Category_code::Rshift, Classic>> { };

                                // -- Rshift_assign --
   // In-place right-shift-expression -- "a >>= b"
   struct Rshift_assign : Binary<Category<Category_code::Rshift_assign, Classic>> { };

                                // -- Static_cast --
   // An expression of the form "static_cast<type>(expr)".
   struct Static_cast : Cast_expr<Category_code::Static_cast> { };

                                // -- Widen --
   // Derived to base class conversion
   struct Widen : Binary<Category<Category_code::Widen>, const Expr&, const Type&> {
      Arg1_type expr() const { return first(); }
      Arg2_type base() const { return second(); }
   };

                                // -- Where --
   // An expression referencing declarations or restrictions, local to that expression.
   // The expressions or declarations in `attendant()` are evaluated first, and then
   // `main()` is evaluated in the dynamic evaluation cone established by `attendant()`.
   // As usual, variables declared by bindings in `attendant()` are destructed in reverse 
   // order of declarations at the end of their scopes, which occur after the complete
   // evaluation of `main()`.
   // Note: An `attendant()` of type `Scope` indicates that the where-expression introduces
   //       local bindings.
   struct Where : Binary<Category<Category_code::Where>> {
      const Expr& main() const { return first(); }
      const Expr& attendant() const { return second(); }
      const Type& type() const final { return main().type(); }
   };

                                // -- Static_assert --
   // A static assertion: failure of the `condition()` halts the elaboration phase.
   // No runtime code is ever generated.  Its type is `bool`.
   // Note: A node of this type is typically an operand of `Phased_evaluation`.
   struct Static_assert : Binary<Category<Category_code::Static_assert>,
                                 const Expr&, Optional<String>> {
      const Expr& condition() const { return first(); }
      virtual Optional<String> message() const { return second(); }
   };

                                // -- Substitution --
   // A "Substitution" is a mapping of a parameter to an expression (its value). 
   struct Substitution {
      virtual const Expr& operator[](const Parameter&) const = 0;
   };

                                // -- Instantiation --
   // An instantiation is a computation that substitutes parameters into an expression.
   // While an implicit specialization of a template is a notorious example of an instantiation,
   // just about any expression can be instantiated.  For example, a hidden friend function 
   // defined in a class template is typically instantiated, even though it is not itself a 
   // function template; the branches of a `constexpr if` are instantiated.  Consequently,
   // an Instantiarion is different from a Template_id (a Name).
   // The result of an instantiation may be cached on the side, or directly stored in this node.
   struct Instantiation : Category<Category_code::Instantiation> {
      virtual const Expr& pattern() const = 0;
      virtual const Substitution& substitution() const = 0;
      virtual Optional<Expr> instance() const  = 0;
      const Type& type() const final { return instance().get().type(); }
   };

                                // -- Requires --
   // Representation of a requires-expression.  Despite the presence of `parameters()`, this expression
   // is not a parameterization of expressions in the conventional sense.  In particular the type of
   // a requires-expression is never a mapping in any sense.  It is always `bool`.
   struct Requires : Category<Category_code::Requires> {
      virtual const Parameter_list& parameters() const = 0;
      virtual const Sequence<cxx_form::Requirement>& body() const = 0;
   };

                                // -- New --
   // This node represents a new-expression:
   //    ::_opt new new-placement_opt new-type-id new-initializer_opt
   //    ::_opt new new-placement_opt ( type-id ) new-initializer_opt
   // Semantically, this has a binary structure where the first operand
   // is the placement-list, and the second operand is a construction expression
   // that indicates the new-type-id or the type-id coupled with the new-initializer if any.
   // When the new-initializer is missing, the Enclosure of the Contruction has no delimiter
   // and the arguments of the Enclosure is a Phantom node.
   // The allocator function is indicated by the implementation().
   struct New : Binary<Category<Category_code::New, Classic>,
                       Optional<Expr_list>, const Construction&> {
      // This predicate holds if the new-expression explicitly requested a global allocator.
      virtual bool global_requested() const = 0;
      Optional<Expr_list> placement() const { return first(); }
      const Construction& initializer() const { return second(); }
   };

                                // -- Conditional --
   // This represents the C++ ternary operator ?:.  In principle, it is redundant
   //  with both If and Switch nodes from semantics point of view.  However, 
   // it is necessary for representing templated code
   struct Conditional : Ternary<Category<Category_code::Conditional, Classic>> {
      Arg1_type condition() const { return first(); }
      Arg2_type then_expr() const { return second(); }
      Arg3_type else_expr() const { return third(); }
   };

                                // -- Parameter_list --
   // The sequence of parameter declarations to an abstraction (mapping).  A parameter-list
   // has a declarative region that covers the entirety of the abstraction it is associated with.
   // While a parameter-list node is essentially a container, viewing like an expression allows
   // an operation such as `type()`, yielding a `Product`, that can be useful in constructing the type
   // of the mapping being parameterized.
   struct Parameter_list : Category<Category_code::Parameter_list> {
      virtual const Region& region() const = 0;
      virtual Mapping_level level() const = 0;
      const Product& type() const override = 0;
      virtual const Sequence<Parameter>& elements() const = 0;
      auto begin() const { return elements().begin(); }
      auto end() const { return elements().end(); }
      auto size() const { return elements().size(); }
   };

                                // -- Directive --
   // Standard C++ has grammar hacks where certain constructs are
   // classified as declarations, by they don't actually declare any name.
   // Rather, the modify the behavior of the implementation in certain ways.
   // For example, a using-declaration does not declare a name: it changes
   // the usual name lookup rules to consider new scopes.  A static-assert
   // does not declare anything: it halts translation when a certain condition
   // does not hold; otherwise a no-op.
   // These constructs are generally known as directives.  They were made
   // declarations in Standard C++, so that they could appear at non-local 
   // scopes -- where general declarations live. 
   struct Directive : Expr {
      virtual Phases phases() const = 0;
   protected:
      constexpr Directive(Category_code c) : Expr{ c } { }
   };


                                // -- Directive --
   // Certain expressions are evaluated at designated phased of translation of a C++ program.
   // For example, static_assert-declaration (a declaration in ISO C++, but an expression
   // in IPR) is evaluated at compile-time.  On the other hand, an asm-declaration (again a
   // declaration in ISO C++, but an expression in the IPR) is generally evaluated at 
   // code-generation time.
   struct Phased_evaluation : Category<Category_code::Phased_evaluation, Directive> {
      const Type& type() const final { return expression().type(); }
      virtual const Expr& expression() const = 0;
   };

                                // -- Specifiers_spread --
   // A directive to spread a decl-specifier-seq over a collection of init-declarators.
   // - The init-declarators are given by the `targets()` operation.
   // - The type component of the decl-specifier-seq is given by `type()`.
   // - The non-type component of the decl-specifier-seq is given by `specifiers()`.
   struct Specifiers_spread : Category<Category_code::Specifiers_spread, Directive> {
      virtual DeclSpecifiers specifiers() const = 0;
      virtual const Sequence<cxx_form::Proclamator>& targets() const = 0;
   };

                                // -- Structured_binding --
   // A structured binding is a directive to the compiler to introduce a set of names
   // (either an Alias or a Var) in the current binding environment by taking apart
   // the object value designated by the initializer.
   struct Structured_binding : Category<Category_code::Structured_binding, Directive> {
      virtual DeclSpecifiers specifiers() const = 0;
      virtual Binding_mode mode() const = 0;
      virtual const Sequence<Identifier>& names() const = 0;
      virtual const Expr& initializer() const = 0;
      virtual const Sequence<Decl>& bindings() const = 0;
   };

                                // -- Using_declaration --
   // A using-declaration is directive that instructs the C++ translator to look up
   // a set of names ('designator'), and for each declaration in the qualified lookup 
   // result of a designator create a synonymous declaration, subject to constraints.
   struct Using_declaration : Category<Category_code::Using_declaration, Directive> {
      struct Designator;
      virtual const Sequence<Designator>& designators() const = 0;
   };

   // A using-declarator: a qualified name, along with a denomination mode.
   struct Using_declaration::Designator {
      enum class Mode {
         Normal      = 0x00,              // Normal interpretation of qualified name lookup
         Type        = 0x01,              // The qualified name is assumed to name a type
         Expansion   = 0x02,              // The designator needs expansion
      };

      Designator(const Scope_ref& p, Mode m) : sr{&p}, md{m} { }
      const Scope_ref& path() const { return *sr; }
      Mode mode() const { return md; }
   private:
      const Scope_ref* sr;
      Mode md;
   };

                                // -- Using_directive --
   // A standard C++ using-directive or a using-enum-declaration 
   // (nominating additional scopes) for elaboration purposes.
   // Its type should be "namespace" if it nominates a namespace,
   // or "enum" or "enum class" if it nominates an enumeration.
   struct Using_directive : Category<Category_code::Using_directive, Directive> {
      virtual const Scope& nominated_scope() const = 0;
   };


                                // -- Pragma --
   struct Pragma : Unary<Category<Category_code::Pragma, Directive>, const Sequence<Token>&> {
      const Sequence<Token>& incantation() const { return operand(); }
   };

                                // -- Stmt --
   // The view that a statement is kind of expression does not follow from
   // Standard C++ specification.  It is a design choice we made based on
   // the following facts:
   //    1. We need to have an IPR node that can represent both a
   //       declaration and an expression.  That need is exemplified
   //       by constructs like
   //            if (std::cin >> c) { /* .... */ }
   //       and
   //            if (Call* c = dynamic_cast<Call*>(e)) { /* ... */ }
   //       In the first case we have an expression and in the second
   //       case we have a declaration.  Therefore, we have a diagram
   //       that loooks like
   //
   //              ,----> E.D. <----,
   //              |                |
   //          Expression      Declaration
   //
   //
   //    2. Standard C++ says some declarations are statements, and when
   //       a declaration declares a variable with initialization, the
   //       initializer usually requests code execution.  Therefore, we
   //       chose to say that a declaration is a statement and we get
   //       a similar diagram
   //
   //              ,----> D.S. <----,
   //              |                |
   //         Declaration       Statement
   //
   //    3. In general, IPR is an expression-based language.
   //
   //
   // When combined, the two diagrams yield
   //
   //              ,----> E.D. <---- ----> D.S <----,
   //              |                |               |
   //          Expression      Declaration      Statement
   //
   //
   // Somehow, we have to satisfy that equation.  In a previous design
   // we chose what seemed to be the simplest, i.e. deriving a Statement
   // from an Expr and a Declaration from a Statement.  Doing so
   // however led to numerous questions about some very basic operations on
   // expressions like `arity()' or `type()'.
   //
   // In a second design, we derived a Statement from Node and a
   // Decl from both Expr and Statement.  This led to complications in the
   // class hierarchy and unnecessary complexities.  Therefore, we're back to
   // the view that a statement is an expression, with some simplifications.
   struct Stmt : Expr {
      // The location of this statement in its unit.
      virtual const Unit_location& unit_location() const = 0;
      virtual const Source_location& source_location() const = 0;
      virtual const Sequence<Annotation>& annotation() const = 0;
      virtual const Sequence<Attribute>& attributes() const = 0;

   protected:
      constexpr Stmt(Category_code c) : Expr{ c } { }
   };

                                // -- Expr_stmt --
   // This node class represents an expression statement, e.g.
   //    std::cout << "Hello World" << std::endl;
   // "expr()" is the Expression to evaluate.
   // The type of the entire statement is the type of the expresion.
   struct Expr_stmt : Unary<Category<Category_code::Expr_stmt, Stmt>> {
      const Type& type() const final { return expr().type(); }
      Arg_type expr() const { return operand(); }
   };

                                // -- Labeled_stmt --
   // This node is for labeled-statement:
   //   a. identifier : statement
   //   b. case constant-expression : statement
   //   c. default : statement
   // IPR represents that `label() as an expression so that it can
   // handle "identifier", "case cst-expr" and "default", where cst-expr
   // is an arbitrary constant-expression.
   // In scenario (a), the `label()` is a Symbol whose `name()` is the identifier.
   // The Symbol's `type()` is `void`.
   // In scenario (b), the `label()` is represented directly by the constant-expression.
   // In scenario (c), the `label()` is should be `Lexicon::default_value()`. 
   struct Labeled_stmt : Binary<Category<Category_code::Labeled_stmt, Stmt>,
                                const Expr&, const Expr&> {
      const Type& type() const final { return stmt().type(); }
      const Expr& label() const { return first(); }
      const Expr& stmt() const { return second(); }
   };

                                // -- Block --
   // A Block is any sequence of general expressions bracketed by curly braces.
   // A block may additionally have exception handlers, in which case it corresponds
   // to Standard C++ syntax heavy try-block.  Conventional, plain blocks carry
   // no handlers.
   struct Block : Category<Category_code::Block, Stmt> {
      virtual const Region& region() const = 0;
      const Sequence<Expr>& body() const { return region().body(); }
      virtual const Sequence<Handler>& handlers() const = 0;
      bool try_block() const { return handlers().size() == 0; }
   };

                                // -- Ctor_body --
   // This node represents a constructor "body" consisting of:
   //      (a) member-initializer list, if present; and
   //      (b) the actual body of the constructor
   struct Ctor_body : Binary<Category<Category_code::Ctor_body, Stmt>,
                             const Expr_list&, const Block&> {
      Arg1_type inits() const { return first(); }
      Arg2_type block() const { return second(); }
   };

                                // -- If
   // A classic if-statement.
   struct If : Ternary<Category<Category_code::If, Stmt>,
                       const Expr&, const Expr&, Optional<Expr>> {
      Arg1_type condition() const { return first(); }
      Arg2_type consequence() const { return second(); }
      Arg3_type alternative() const { return third(); }
   };

                                // -- Switch --
   // A classic switch-statement.
   struct Switch : Binary<Category<Category_code::Switch, Stmt>,
                          const Expr&, const Expr&> {
      Arg1_type condition() const { return first(); }
      Arg2_type body() const { return second(); }
   };

                                // -- While --
   // A classic while-statement
   struct While : Binary<Category<Category_code::While, Stmt>,
                         const Expr&, const Expr&> {
      Arg1_type condition() const { return first(); }
      Arg2_type body() const { return second(); }
   };

                                // -- Do --
   // A classic do-statement
   struct Do : Binary<Category<Category_code::Do, Stmt>, const Expr&, const Expr&> {
      Arg1_type condition() const { return first(); }
      Arg2_type body() const { return second(); }
   };

                                // -- For --
   // A classic for-statement
   struct For : Category<Category_code::For, Stmt> {
      virtual const Expr& initializer() const = 0;
      virtual const Expr& condition() const = 0;
      virtual const Expr& increment() const = 0;
      virtual const Expr& body() const = 0;
   };

                                // -- For_in --
   struct For_in : Category<Category_code::For_in, Stmt> {
      virtual const Var& variable() const = 0;
      virtual const Expr& sequence() const = 0;
      virtual const Expr& body() const = 0;
   };

                                // -- Break --
   // A classic break-statement.
   // It has type `void`.
   struct Break : Category<Category_code::Break, Stmt> {
      virtual const Stmt& from() const = 0;
   };

                                // -- Continue --
   // A classic continue-statement.
   // It has type `void`.
   struct Continue : Category<Category_code::Continue, Stmt> {
      virtual const Stmt& iteration() const = 0;
   };

                                // -- Goto --
   // A classic goto-statement.
   // The type of the entire statement is the `type()` of the operand.
   struct Goto : Unary<Category<Category_code::Goto, Stmt>> {
      const Type& type() const final { return target().type(); }
      Arg_type target() const { return operand(); }
   };

                                // -- Return --
   // A classic return-statement.
   struct Return : Unary<Category<Category_code::Return, Stmt>> {
      Arg_type value() const { return operand(); }
   };

                                // -- Handler --
   // This represents a catch-clause.  Notice that there is no node
   // for "try" as every Block is implicitly a try-block.  Ideally, we
   // should have every expression as a "try-block".
   struct Handler : Category<Category_code::Handler, Stmt> {
      virtual const EH_parameter& exception() const = 0;
      virtual const Block& body() const = 0;
   };

                                // -- Decl --
   // Only declaration-statements are statements from Standard C++ perspective.
   // However, we find it simpler just to take the general rule that a declaration
   //  is a statement. Furthermore, it should be observed that declarations like
   //   (a) function-definition
   //   (b) template-declaration
   //   (c) explicit-instantiation
   //   (d) explicit-specialization
   //   (e) linkage-specification
   //   (f) namespace-definition
   // are not statement in Standard C++ sense.
   //
   // We take the view that all declarations can be parameterized.
   // Therefore, declaration nodes potentially are instantiations of a
   // a template given by "pattern()", with a set of template-arguments,
   // given by "substitutions()".  A declaration for which we have
   // an empty substitutions() is either
   //     (a) a primary template; or
   //     (b) a non-template declaration.
   struct Decl : Stmt {
      virtual DeclSpecifiers specifiers() const = 0;
      virtual const Linkage& linkage() const = 0;

      virtual const Name& name() const = 0;

      // The region where the declaration really belongs to.
      virtual const Region& home_region() const = 0;

      // The region where this declaration appears -- purely lexical.
      // For many declarations, this is the same as the home region.
      // Exceptions are invisible friends, member functions defined
      // outside of their enclosing class or namespaces.
      virtual const Region& lexical_region() const = 0;

      virtual Optional<Expr> initializer() const = 0;

      // This is the first seen declaration for name() in a given
      // translation unit.  The master declaration is therefore the
      // first element of the declaration-set.
      virtual const Decl& master() const = 0;

      virtual const Sequence<Decl>& decl_set() const = 0;

   protected:
      constexpr Decl(Category_code c) : Stmt{ c } { }
   };

                                // -- Template --
   // This represents a parameterized declaration.  If its
   // template-parameter list is empty, that means that it is
   // either an explicit specialization -- if result() has a
   // non-empty substitutions() -- or a really non-template
   // declaration  -- if result().substitutions() is empty.
   // The list of specializations of this template (either
   // partial or explicit) is given by specializations().
   struct Template : Category<Category_code::Template, Decl> {
      virtual const Template& primary_template() const = 0;
      virtual const Sequence<Decl>& specializations() const = 0;
      virtual const Mapping& mapping() const = 0;

      const Parameter_list& parameters() const { return mapping().parameters(); }
      const Expr& result() const { return mapping().result(); }

      virtual Optional<Template> definition() const = 0;
   };

                                // -- Enumerator --
   // This represents a classic enumerator.
   struct Enumerator : Category<Category_code::Enumerator, Decl> {
      virtual Decl_position position() const = 0;
   };

                                // - Alias --
   // This represent a alias declaration (e.g. typedef, namespace-alias,
   // template alias, a binding in a structured binding, etc).
   // An alias is always initialized -- with what it is an alias for.
   // The type of an Alias expression is that of its initializer.
   struct Alias : Category<Category_code::Alias, Decl> {
      const Region& lexical_region() const final { return home_region(); }
   };

                                // -- Base_type --
   // Each base-specifier in a base-clause morally declares an unnamed
   // subobject.  We represent that subobject declaration by a Base_type.
   // For consistency with other non-static members, the name of that
   // subobject is pretended to be the same as that of the base-class
   // so that when it appears in a member-initializer list, it can
   // conveniently be thought of as initialization of that subobject.
   struct Base_type : Category<Category_code::Base_type, Decl> {
      // A base-object is, by definition, unnamed.  However, it
      // is convenient to refer to it by the name of the corresponding
      // type -- in C++ tradition.
      const Name& name() const final { return type().name(); }
      virtual Decl_position position() const = 0;
   };

                                // -- Parameter --
   // A parameter is uniquely characterized by its position in
   // a parameter list.
   struct Parameter : Category<Category_code::Parameter, Decl> {
      virtual Mapping_level level() const = 0;
      virtual Decl_position position() const = 0;
      const Region& lexical_region() const final { return home_region(); }
      Optional<Expr> default_value() const { return initializer(); }
   };

                                // -- EH_parameter --
   // Parameter to an exception handler block.  In many aspects, it functions
   // like a function parameter, except its initialization is not lexical the
   // way functional parameters are.  Futhermore, they cannot have default values,
   // and there is exactly one parameter per handler (unlike functions).
   struct EH_parameter : Category<Category_code::EH_parameter, Decl> {
      Optional<Expr> initializer() const final { return { }; }
   };

                                // -- Fundecl --
   // This node represents a function declaration. Notice that the
   // exception specification is actually made part of the function type.
   struct Fundecl : Category<Category_code::Fundecl, Decl> {
      virtual Optional<Mapping> mapping() const = 0;
      virtual const Parameter_list& parameters() const = 0;
      virtual Optional<Fundecl> definition() const = 0;
   };

                                // -- Var --
   // This represents a variable declaration.  It is also used to
   // represent a static data member.
   struct Var : Category<Category_code::Var, Decl> {
      virtual Optional<Var> definition() const = 0;
   };

                                // -- Field --
   // This node represents a nonstatic data member.
   struct Field : Category<Category_code::Field, Decl> {
      const Region& lexical_region() const final { return home_region(); }
   };

                                // -- Bitfield --
   // A bit-field data member.
   struct Bitfield : Category<Category_code::Bitfield, Decl> {
      virtual const Expr& precision() const = 0;
      const Region& lexical_region() const final { return home_region(); }
   };

                                // -- Typedecl --
   // This node class represents a declaration of a user-defined type.
   struct Typedecl : Category<Category_code::Typedecl, Decl> {
      virtual Optional<Typedecl> definition() const = 0;
   };

                                // -- Translation_unit --
   struct Translation_unit {
      struct Visitor;
      virtual void accept(Visitor&) const = 0;
      virtual const ipr::Namespace& global_namespace() const = 0;
      virtual const Sequence<Module>& imported_modules() const = 0;
   };

                                // -- Module_unit --
   struct Module_unit : Translation_unit {
      virtual const Module& parent_module() const = 0;
      virtual const Sequence<Decl>& purview() const = 0;
   };

                                // -- Interface_unit --
   struct Interface_unit : Module_unit {
      virtual const Sequence<Module>& exported_modules() const = 0;
      virtual const Sequence<Decl>& exported_declarations() const = 0;
   };

                                // -- Module --
   struct Module {
      virtual const Module_name& name() const = 0;
      virtual const Interface_unit& interface_unit() const = 0;
      virtual const Sequence<Module_unit>& implementation_units() const = 0;
   };

                                // -- Lexicon --
   // This class is intended to capture the set of values for the parameters
   // of the C++ abstract machine.  The most prominent such parameters are
   // the built-int types of the implementation.  It is expected that a given
   // tool can inherit from this class and provide access to the full range of
   // extended types and values that it implements.
   struct Lexicon {
      virtual const Type& void_type() const = 0;               // "void"
      virtual const Type& bool_type() const = 0;               // "bool"
      virtual const Type& char_type() const = 0;               // "char"
      virtual const Type& schar_type() const = 0;              // "signed char"
      virtual const Type& uchar_type() const = 0;              // "unsigned char"
      virtual const Type& wchar_t_type() const = 0;            // "wchar_t"
      virtual const Type& char8_t_type() const = 0;            // "char8_t"
      virtual const Type& char16_t_type() const = 0;           // "char16_t"
      virtual const Type& char32_t_type() const = 0;           // "char32_t"
      virtual const Type& short_type() const = 0;              // "short"
      virtual const Type& ushort_type() const = 0;             // "unsigned char"
      virtual const Type& int_type() const = 0;                // "int"
      virtual const Type& uint_type() const = 0;               // "unsigned int"
      virtual const Type& long_type() const = 0;               // "long"
      virtual const Type& ulong_type() const = 0;              // "unsigned long"
      virtual const Type& long_long_type() const = 0;          // "long long"
      virtual const Type& ulong_long_type() const = 0;         // "unsigned long long"
      virtual const Type& float_type() const = 0;              // "float"
      virtual const Type& double_type() const = 0;             // "double"
      virtual const Type& long_double_type() const = 0;        // "long double"
      virtual const Type& ellipsis_type() const = 0;           // "..."
      virtual const Type& typename_type() const = 0;           // "typename"
      virtual const Type& class_type() const = 0;              // "class" or "struct"
      virtual const Type& union_type() const = 0;              // "union"
      virtual const Type& enum_type() const = 0;               // "enum" or "enum class"
      virtual const Type& namespace_type() const = 0;          // "namespace"

      virtual const Symbol& false_value() const = 0;           // Boolean symbolic constant 'false'
      virtual const Symbol& true_value() const = 0;            // Boolean symbolic constant 'true'
      
      virtual const Symbol& nullptr_value() const = 0;         // "nullptr"      -- technically not a parameter
                                                               // to the C++ abstract machine, but provided as
                                                               // example of symbolic value representation.
      virtual const Symbol& default_value() const = 0;         // "default" - as initializer for defaulted definition
                                                               //             and as default value for case in labeled statements.
      virtual const Symbol& delete_value() const = 0;          // "delete" - as initializer in deleted function definitions.

      virtual const Linkage& cxx_linkage() const = 0;          // constant for 'extern "C++"'
      virtual const Linkage& c_linkage() const = 0;            // constant for 'extern "C"'
   };

                                // -- Visitor --
   struct Visitor {
      virtual void visit(const Node&) = 0;

      virtual void visit(const Annotation&);
      virtual void visit(const Region&);
      virtual void visit(const Comment&);
      virtual void visit(const String&);

      virtual void visit(const Expr&) = 0;
      virtual void visit(const Classic&);

      virtual void visit(const Name&) = 0;
      virtual void visit(const Identifier&);
      virtual void visit(const Suffix&);
      virtual void visit(const Operator&);
      virtual void visit(const Conversion&);
      virtual void visit(const Template_id&);
      virtual void visit(const Type_id&);
      virtual void visit(const Ctor_name&);
      virtual void visit(const Dtor_name&);
      virtual void visit(const Guide_name&);

      virtual void visit(const Type&) = 0;
      virtual void visit(const Array&);
      virtual void visit(const Class&);
      virtual void visit(const Closure&);
      virtual void visit(const Decltype&);
      virtual void visit(const Enum&);
      virtual void visit(const As_type&);
      virtual void visit(const Tor&);
      virtual void visit(const Function&);
      virtual void visit(const Namespace&);
      virtual void visit(const Pointer&);
      virtual void visit(const Ptr_to_member&);
      virtual void visit(const Product&);
      virtual void visit(const Qualified&);
      virtual void visit(const Reference&);
      virtual void visit(const Rvalue_reference&);
      virtual void visit(const Sum&);
      virtual void visit(const Forall&);
      virtual void visit(const Union&);
      virtual void visit(const Auto&);

      virtual void visit(const Expr_list&);
      virtual void visit(const Overload&);
      virtual void visit(const Scope&);
      virtual void visit(const Phantom&);
      virtual void visit(const Eclipsis&);
      virtual void visit(const Lambda&);
      virtual void visit(const Requires&);

      virtual void visit(const Symbol&);
      virtual void visit(const Address&);
      virtual void visit(const Array_delete&);
      virtual void visit(const Asm&);
      virtual void visit(const Complement&);
      virtual void visit(const Delete&);
      virtual void visit(const Demotion&);
      virtual void visit(const Deref&);
      virtual void visit(const Enclosure&);
      virtual void visit(const Alignof&);
      virtual void visit(const Sizeof&);
      virtual void visit(const Args_cardinality&);
      virtual void visit(const Restriction&);
      virtual void visit(const Expr_stmt&);
      virtual void visit(const Typeid&);
      virtual void visit(const Id_expr&);
      virtual void visit(const Label&);
      virtual void visit(const Not&);
      virtual void visit(const Materialization&);
      virtual void visit(const Post_decrement&);
      virtual void visit(const Post_increment&);
      virtual void visit(const Pre_decrement&);
      virtual void visit(const Pre_increment&);
      virtual void visit(const Promotion&);
      virtual void visit(const Read&);
      virtual void visit(const Throw&);
      virtual void visit(const Unary_minus&);
      virtual void visit(const Unary_plus&);
      virtual void visit(const Expansion&);
      virtual void visit(const Noexcept&);

      virtual void visit(const Rewrite&);
      virtual void visit(const Scope_ref&);
      virtual void visit(const And&);
      virtual void visit(const Array_ref&);
      virtual void visit(const Arrow&);
      virtual void visit(const Arrow_star&);
      virtual void visit(const Assign&);
      virtual void visit(const Bitand&);
      virtual void visit(const Bitand_assign&);
      virtual void visit(const Bitor&);
      virtual void visit(const Bitor_assign&);
      virtual void visit(const Bitxor&);
      virtual void visit(const Bitxor_assign&);
      virtual void visit(const Cast&);
      virtual void visit(const Call&);
      virtual void visit(const Coercion&);
      virtual void visit(const Comma&);
      virtual void visit(const Const_cast&);
      virtual void visit(const Construction&);
      virtual void visit(const Div&);
      virtual void visit(const Div_assign&);
      virtual void visit(const Dot&);
      virtual void visit(const Dot_star&);
      virtual void visit(const Dynamic_cast&);
      virtual void visit(const Equal&);
      virtual void visit(const Greater&);
      virtual void visit(const Greater_equal&);
      virtual void visit(const Less&);
      virtual void visit(const Less_equal&);
      virtual void visit(const Literal&);
      virtual void visit(const Lshift&);
      virtual void visit(const Lshift_assign&);
      virtual void visit(const Member_init&);
      virtual void visit(const Minus&);
      virtual void visit(const Minus_assign&);
      virtual void visit(const Modulo&);
      virtual void visit(const Modulo_assign&);
      virtual void visit(const Mul&);
      virtual void visit(const Mul_assign&);
      virtual void visit(const Narrow&);
      virtual void visit(const Not_equal&);
      virtual void visit(const Or&);
      virtual void visit(const Plus&);
      virtual void visit(const Plus_assign&);
      virtual void visit(const Pretend&);
      virtual void visit(const Qualification&);
      virtual void visit(const Reinterpret_cast&);
      virtual void visit(const Rshift&);
      virtual void visit(const Rshift_assign&);
      virtual void visit(const Static_cast&);
      virtual void visit(const Widen&);
      virtual void visit(const Binary_fold&);
      virtual void visit(const Where&);
      virtual void visit(const Static_assert&);
      virtual void visit(const Instantiation&);

      virtual void visit(const Conditional&);
      virtual void visit(const New&);
      virtual void visit(const Mapping&);

      virtual void visit(const Directive&) = 0;
      virtual void visit(const Specifiers_spread&);
      virtual void visit(const Structured_binding&);
      virtual void visit(const Using_declaration&);
      virtual void visit(const Using_directive&);
      virtual void visit(const Phased_evaluation&);
      virtual void visit(const Pragma&);

      virtual void visit(const Stmt&) = 0;
      virtual void visit(const Labeled_stmt&);
      virtual void visit(const Block&);
      virtual void visit(const Ctor_body&);
      virtual void visit(const If&);
      virtual void visit(const Switch&);
      virtual void visit(const While&);
      virtual void visit(const Do&);
      virtual void visit(const For&);
      virtual void visit(const For_in&);
      virtual void visit(const Break&);
      virtual void visit(const Continue&);
      virtual void visit(const Goto&);
      virtual void visit(const Return&);
      virtual void visit(const Handler&);

      virtual void visit(const Decl&) = 0;
      virtual void visit(const Alias&);
      virtual void visit(const Base_type&);
      virtual void visit(const Bitfield&);
      virtual void visit(const Enumerator&);
      virtual void visit(const Field&);
      virtual void visit(const Fundecl&);
      virtual void visit(const Template&);
      virtual void visit(const Parameter&);
      virtual void visit(const Parameter_list&);
      virtual void visit(const Typedecl&);
      virtual void visit(const Var&);
      virtual void visit(const EH_parameter&);
   };

                                // -- Translation_unit::Visitor --
   struct Translation_unit::Visitor {
      virtual void visit(const Translation_unit&) = 0;
      virtual void visit(const Module_unit&);
      virtual void visit(const Interface_unit&);
   };
}

#endif // IPR_INTERFACE_INCLUDED
